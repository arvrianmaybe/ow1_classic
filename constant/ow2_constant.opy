settings
{
	main
	{
		Mode Name: "Overwatch 1++ Classic Developer Build"
		Description: "Overwatch 1++ Classic Developer Build\n\nOverwatch 1 Classic++ (YVE2X)\nPlay launch version of ow1 or ow2 heroes.\n\nMain build: NC336\nStaging build: nothing\n\nGamemode forked from\nOverwatch 1 Emulator v1.12.2 (KHTG0)\nby ecksdee#11729\n\nCodebase Contributors:\nviper\necksdee#4643\nwadetata#0315\n\nworkshop.codes/remastered\n\nDiscord:\ndsc.gg/runece\ndiscord.gg/vb5r2gfNTQ\n\nSource code:\nhttps://github.com/arvrianmaybe/ow1_classic"
	}
	lobby
	{
		Allow Players Who Are In Queue: Yes
		Map Rotation: After A Game
		Match Voice Chat: Enabled
		Max Spectators: 12
		Max Team 1 Players: 6
		Max Team 2 Players: 0
		Return To Lobby: Never
	}
	modes
	{
		Practice Range
		{
			enabled maps
			{
				Practice Range
			}
		}
		General
		{
			Hero Limit: 1 Per Team
			Limit Roles: Off
			Game Mode Start: All Slots Filled
			Tank Role Passive Health Bonus: Disabled
			Competitive Rules: On
		}
	}
	heroes
	{
		General
		{
			Ana
			{
				Sleep Dart Cooldown Time: 85.71428571428571%
				Biotic Grenade Cooldown Time: 83.33333333333334%
				Ultimate Generation Nano Boost: 91.30434782608695%
			}
			Ashe
			{
				Health: 120%
				Ultimate Generation B.O.B.: 109.375%
			}
			Baptiste
			{
				Health: 160%
				Immortality Field Cooldown Time: 120%
				Ultimate Generation Amplification Matrix: 110.3896103896104%
			}
			Bastion
			{
				Reconfigure Cooldown Time: 0%
				Ammunition Clip Size Scalar: 80%
				Ultimate Generation Configuration: Artillery: 108.22510822510823%
			}
			Brigitte
			{
				Health: 240%
				Shield Bash Cooldown Time: 100%
				Shield Bash Knockback Scalar: 100%
				Repair Pack Cooldown Time: 120%
				Ultimate Generation Rally: 140.42105263157896%
			}
			Cassidy
			{
				Flashbang Cooldown Time: 83.33333333333334%
				Ultimate Generation Deadeye: 111.11111111111111%
			}
			Doomfist
			{
				Ammunition Regeneration Time Scalar: 162%
				Rocket Punch Knockback Scalar: 0%
				Ultimate Generation Meteor Strike: 134.0625%
			}
			D.Va
			{
				Defense Matrix Recharge Rate: 500%
				Health: 85.71428571428571%
				Defense Matrix Maximum Time: 133.33333333333331%
				Boosters Cooldown Time: 200%
				Micro Missiles Cooldown Time: 171.42857142857142%
				Ultimate Generation Self-Destruct: 85.47008547008546%
			}
			Echo
			{
				Ultimate Generation Duplicate: 92.5%
			}
			Genji
			{
				Ultimate Duration: 120%
				Ultimate Generation Dragonblade: 88.54166666666666%
			}
			Hanzo
			{
				Lunge: Off
				Sonic Arrow Cooldown Time: 166.66666666666669%
				Storm Arrows Cooldown Time: 125%
				Ultimate Generation Dragonstrike: 115.625%
			}
			Junkrat
			{
				Concussion Mine Cooldown Time: 100%
				Ultimate Generation RIP-Tire: 95.45454545454545%
			}
			Junker Queen
			{
				Commanding Shout Cooldown Time: 107.14285714285714%
				Ultimate Generation Rampage: 96.29629629629629%
			}
			Kiriko
			{
				Swift Step Cooldown Time: 128.57142857142858%
				Protection Suzu Cooldown Time: 100%
				Ultimate Generation Kitsune Rush: 114.85148514851484%
			}
			Lifeweaver
			{
				Health: 25%
				Ultimate Generation Tree of Life: 72.72727272727273%
			}
			Lúcio
			{
				Ultimate Generation Sound Barrier: 113.20754716981132%
				Amp It Up Cooldown Time: 125%
			}
			Illari
			{
				Health: 100%
				Ultimate Generation Captive Sun: 113.20754716981132%
				Outburst Cooldown Time: 138.57142857142856%
				Healing Pylon Cooldown Time: 283.33333333333337%
			}
			Mei
			{
				Health: 80%
				Ultimate Generation Blizzard: 119.56521739130434%
			}
			Mercy
			{
				Ultimate Generation Valkyrie: 100%
				Sympathetic Recovery: Off
			}
			Mauga
			{
				Ultimate Generation Cage Fight: 79.24528301886792%
			}
			Moira
			{
				Ultimate Generation Coalescence: 115.99999999999999%
				Ultimate Duration: 75%
				Biotic Energy Maximum: 269.9055330634278%
			}
			Orisa
			{
				Ultimate Generation Terra Surge: 78.13953488372093%
			}
			Pharah
			{
				Hover Jets Extra Fuel Scalar: 0%
				Jump Jet Cooldown Time: 78.57142857142857%
				Concussive Blast Cooldown Time: 142.85714285714286%
				Ultimate Generation Barrage: 100%
			}
			Reaper
			{
				Ultimate Generation Death Blossom: 106.95187165775401%
			}
			Reinhardt
			{
				Barrier Field Recharge Rate: 138.88888888888889%
				Health: 125%
				Charge Cooldown Time: 142.85714285714286%
				Ultimate Generation Earthshatter: 83.33333333333334%
			}
			Roadhog
			{
				Chain Hook Cooldown Time: 100%
				Pig Pen Cooldown Time: 66.66666666666666%
				Take a Breather Maximum Time: 60%
				Take a Breather Recharge Rate: 500%
				Ultimate Generation Whole Hog: 136.16071428571428%
			}
			Sigma
			{
				Experimental Barrier Recharge Rate: 82.35294117647058%
				Health: 142.85714285714286%
				Ultimate Generation Gravitic Flux: 143.75%
			}
			Ramattra
			{
				Health: 100%
				Nemesis Form Cooldown Time: 214.28571428571428%
				Ultimate Generation Annihilation: 113.04347826086956%
			}
			Soldier: 76
			{
				Biotic Field Cooldown Time: 83.33333333333334%
				Ultimate Generation Tactical Visor: 157.14285714285714%
			}
			Sombra
			{
				Hack Cooldown Time: 166.66666666666669%
				Ultimate Generation EMP: 91.25%
			}
			Sojourn
			{
				Power Slide Cooldown Time: 142.85714285714286%
				Ultimate Generation Overclock: 108.69565217391303%
			}
			Symmetra
			{
				Health: 75%
				Ultimate Generation Photon Barrier: 92.04545454545455%
			}
			Torbjörn
			{
				Health: 66.66666666666666%
				Ultimate Generation Molten Core: 106.81818181818181%
			}
			Tracer
			{
				Health: 85.71428571428571%
				Ultimate Generation Pulse Bomb: 91.66666666666666%
			}
			Venture
			{
				Ultimate Generation Tectonic Shock: 100%
			}
			Winston
			{
				Health: 107.6923076923077%
				Jump Pack Cooldown Time: 120%
				Ultimate Generation Primal Rage: 89.13043478260869%
			}
			Wrecking Ball
			{
				Grappling Claw Knockback Scalar: 75.18796992481202%
				Ultimate Generation Minefield: 108.8235294117647%
				Piledriver Cooldown Time: 125%
			}
			Zarya
			{
				Health: 100%
				Ultimate Generation Graviton Surge: 68.08169803764518%
			}
			Zenyatta
			{
				Ultimate Generation Transcendence: 102%
			}
			enabled heroes
			{
				Ana
				Ashe
				Baptiste
				Bastion
				Brigitte
				Cassidy
				Doomfist
				D.Va
				Echo
				Genji
				Hanzo
				Illari
				Junker Queen
				Junkrat
				Kiriko
				Lifeweaver
				Lúcio
				Mauga
				Mei
				Mercy
				Moira
				Orisa
				Pharah
				Ramattra
				Reaper
				Reinhardt
				Roadhog
				Sigma
				Sojourn
				Soldier: 76
				Sombra
				Symmetra
				Torbjörn
				Tracer
				Venture
				Widowmaker
				Winston
				Wrecking Ball
				Zarya
				Zenyatta
			}
		}
	}
}
variables {
    global:
        0: DOOMFIST_PUNCH_COOLDOWN
        1: DOOMFIST_UPPERCUT_COOLDOWN
        2: DOOMFIST_SLAM_DAMAGE_MAX
        3: DOOMFIST_SLAM_PITCH_ANGLE
        4: DOOMFIST_SEISMIC_SLAM_RADIUS
        5: ORISA_BARRIER_ORB_SIZE
        6: ORISA_BARRIER_ORB_COUNT
        7: ORISA_BARRIER_LOS_FREQ
        8: reset_gvar
        9: ready_gvar
        10: READY_THRESHOLD_PERCENT
        11: ANTI_CRASH_ACTIVATE_PERCENT
        12: ANTI_CRASH_HOLD_TIME
        13: ANTI_CRASH_DEACTIVATE_PERCENT
        14: slam_i
        15: health_pool
        16: los_i
        17: los_j
        18: barrier_i
        19: ULT_DURATION_WORKSHOP_SETTINGS
        20: ULT_DURATION_MAX
        21: teleporter1
        22: teleporter2
        23: shield_gen
        24: radius
        25: DEBUG_MODE
    player:
        0: stat_helper_pvar
        1: custom_hp_pvar
        2: reset_pvar
        3: ult_charge_pvar
        4: self_heal_pvar
        5: hero_switch_pvar
        6: ready_pvar
        7: ready_hud
        8: ready_hud_i
        9: hit_detection_pvar
        10: lsi_i
        11: sleep_pvar
        12: nano_boost_speed
        13: ult_point_while_ult_active
        14: start_time_ult
        15: current_configuration
        16: repair_pvar
        17: self_repair_time_left
        18: machine_gun_ammo
        19: machine_gun_ready
        20: machine_gun_reload_timer
        21: machine_gun_ammo_id
        22: repair_pack_armor
        23: rally_hot_id
        24: rally_pvar
        25: flashbang_pvar
        26: is_using_uppercut
        27: is_ultimate_locked
        28: uppercut_pvar
        29: uppercut_shields
        30: slam_to_use
        31: proto_indicator_slam_position
        32: indicator_slam_position
        33: slam_damage
        34: slam_victims
        35: slam_velocity_correction
        36: stop_slam
        37: slam_indicator_beam_id
        38: slam_indicator_ring_id
        39: punched_victims
        40: wall_impacted_victims
        41: punch_charge_time
        42: meteor_strike_slow_time
        43: remech_damage_taken
        44: hero_id_duplicated
        45: scatter_pvar
        46: extend_player_collection
        47: hammond_shield_pvar
        48: jq_self_heal_id
        49: parting_pvar
        50: parting_gift_position
        51: cross_fade_stats
        52: cross_fade_index
        53: cross_fade_effects
        54: freeze_progress
        55: freeze_slow_linger_time
        56: freeze_move_penalty
        57: is_using_guardian_angel
        58: is_slingshotting
        59: slingshot_velocity
        60: resurrect_pvar
        61: mercy_res_id
        62: fusion_driver_pvar
        63: barrier_pvar
        64: barrier_seed_t
        65: barrier_seed_velocity
        66: barrier_seed_position
        67: barrier_entity_positions
        68: barrier_entity_colors
        69: barrier_uptime
        70: halt_pvar
        71: position
        72: halt_position
        73: halt_ending_position
        74: supercharger_pvar
        75: ammo
        76: ult_duration
        77: ram_progress_bar
        78: soul_pvar
        79: orb_pos
        80: breather_pvar
        81: hack_timer
        82: wholehog_pvar
        83: scrap_gun_pvar
        84: scrap_i
        85: emp_pvar
        86: stealth_pvar
        87: translocator_pvar
        88: transloc_position
        89: trasnloc_velocity
        90: transloc_p0
        91: transloc_v0
        92: transloc_time
        93: call_throwTranslocator
        94: hp
        95: shield_pvar
        96: beam_visibility
        97: beam_multiplier_dmg
        98: beam_effects
        99: shield_gen
        100: shield_gen_pvar
        101: cords
        102: objective
        103: teleporter_up
        104: teleporter_used
        105: fall_off_pvar
        106: primal_pvar
        107: self_bubble_cooldown
        108: self_bubble_cd_text
        109: ally_bubble_cooldown
        110: ally_bubble_cd_text
        111: discord_orb_damage
        112: debug_pvar
}
subroutines {
    0: clearCustomHp
    1: applyCustomHp
    2: enableAllAbilities
    3: disableAllAbilities
    4: resetStats
    5: resetStatuses
    6: resetFrenemies
    7: resetUltCharge
    8: resetSelfHealing
    9: findLineSphereIntersection
    10: startFiring
    11: reloadMachineGun
    12: startRally
    13: endRally
    14: initSlam
    15: executeSlam
    16: startSlamAnimation
    17: createSlamIndicatorGui
    18: destroySlamIndicatorGui
    19: initRocketPunch
    20: fireScatterArrow
    21: lucioAura
    22: cleanUpAura
    23: clearFreezeEffect
    24: startMassRes
    25: stopMassRes
    26: resetFusionDriver
    27: reloadFusionDriver
    28: showOrisaAmmoHud
    29: hideOrisaAmmoHud
    30: throwBarrier
    31: deployBarrier
    32: destroyBarrier
    33: fibonacciSphere
    34: createBarrierHud
    35: destroyBarrierHud
    36: updateBarrierVisual
    37: shootHalt
    38: explodeHalt
    39: showSnareLine
    40: hideSnareLine
    41: startSupercharger
    42: endSupercharger
    43: cancelWholehog
    44: enterStealth
    45: exitStealth
    46: showStealthHud
    47: throwTranslocator
    48: destroyTranslocator
    49: showTranslocator
    50: showTranslocatorIcon
    51: hideTranslocator
    52: createTeleporter
    53: destroyTeleporter
}
rule ("Initialize global variables") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable(DOOMFIST_PUNCH_COOLDOWN, Workshop Setting Real(Custom String("Doomfist", Null, Null, Null), Custom String("Cooldown - Punch", Null, Null, Null), 4, 0, 12, 0));
        Set Global Variable(DOOMFIST_UPPERCUT_COOLDOWN, Workshop Setting Real(Custom String("Doomfist", Null, Null, Null), Custom String("Cooldown - Uppercut", Null, Null, Null), 7, 0, 12, 0));
        Set Global Variable(DOOMFIST_SLAM_DAMAGE_MAX, Workshop Setting Integer(Custom String("Doomfist", Null, Null, Null), Custom String("Slam Max Damage", Null, Null, Null), 125, 0, 1000, 0));
        Set Global Variable(DOOMFIST_SLAM_PITCH_ANGLE, Workshop Setting Real(Custom String("Doomfist", Null, Null, Null), Custom String("Max Indicator Slam Pitch", Null, Null, Null), 10, -90, 90, 0));
        Set Global Variable(DOOMFIST_SEISMIC_SLAM_RADIUS, Workshop Setting Real(Custom String("Doomfist", Null, Null, Null), Custom String("Max Indicator Slam Range", Null, Null, Null), 15, 0, 30, 0));
        Set Global Variable(ORISA_BARRIER_ORB_SIZE, Workshop Setting Real(Custom String("Orisa", Null, Null, Null), Custom String("Barrier Orb Radius", Null, Null, Null), 0.25, 0.1, 3, 0));
        Set Global Variable(ORISA_BARRIER_ORB_COUNT, Workshop Setting Integer(Custom String("Orisa", Null, Null, Null), Custom String("Barrier Orb Count", Null, Null, Null), 140, 100, 200, 0));
        Set Global Variable(ORISA_BARRIER_LOS_FREQ, Workshop Setting Real(Custom String("Orisa", Null, Null, Null), Custom String("Barrier LOS Polling Frequency (Hz)", Null, Null, Null), 1, 0.001, 60, 0));
        Set Global Variable(READY_THRESHOLD_PERCENT, Workshop Setting Integer(Custom String("Lobby", Null, Null, Null), Custom String("Ready Threshold", Null, Null, Null), 75, 0, 100, 0));
        Set Global Variable(ANTI_CRASH_ACTIVATE_PERCENT, Workshop Setting Integer(Custom String("Anti Crash", Null, Null, Null), Custom String("Activation Percent", Null, Null, Null), 200, 0, 250, 0));
        Set Global Variable(ANTI_CRASH_HOLD_TIME, Workshop Setting Real(Custom String("Anti Crash", Null, Null, Null), Custom String("Activation Hold Time", Null, Null, Null), 8, 0, 20, 0));
        Set Global Variable(ANTI_CRASH_DEACTIVATE_PERCENT, Workshop Setting Integer(Custom String("Anti Crash", Null, Null, Null), Custom String("Deactivation Percent", Null, Null, Null), 150, 0, 250, 0));
        Set Global Variable(ULT_DURATION_WORKSHOP_SETTINGS, Workshop Setting Integer(Custom String("Ramattra ult", Null, Null, Null), Custom String("Annihilation duration", Null, Null, Null), 4, 1, 20, 0));
        Set Global Variable(ULT_DURATION_MAX, Global.ULT_DURATION_WORKSHOP_SETTINGS);
        Set Global Variable(DEBUG_MODE, Workshop Setting Toggle(Custom String("Dev Tools", Null, Null, Null), Custom String("debug mode", Null, Null, Null), True, 0));
    }
}

rule ("Copyright (c) 2024 Overwatch 1 Classic. See https://github.com/arvrianmaybe/ow1_classic for license to use this code.") {
    event {
        Ongoing - Global;
    }
    actions {
        "this code has been forked by overwatch 1 emulator, please also check theres https://github.com/Overwatch-1-Emulator/ow1-emulator"
        Disable Inspector Recording;
    }
}

rule ("[passives/damage/damage_passive.opy]: Remove DPS passive (Dealing damage reduces enemy healing received)") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Array Contains(All Damage Heroes, Hero Of(Event Player)) == True;
    }
    actions {
        Set Healing Received(Victim, 125);
        Wait(2, Restart When True);
        Set Healing Received(Victim, 100);
    }
}

rule ("[utilities/stat_helper.opy]: ow1 melee damage") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Event Ability == Button(Melee);
        Array Contains(Array(Hero(Brigitte), Hero(Reinhardt), Hero(Zenyatta)), Hero Of(Event Player)) == False;
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Multiply(0.75, Divide(Event Damage, First Of((Event Player).stat_helper_pvar)))));
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.75, Divide(Event Damage, First Of((Event Player).stat_helper_pvar))), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[passives/tank/headshot.opy]: remove tank headshot damage") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Event Was Critical Hit == True;
        Array Contains(All Tank Heroes, Hero Of(Victim)) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(1.333333333333333, Divide(Event Damage, First Of((Attacker).stat_helper_pvar))), Event Damage), First Of((Attacker).stat_helper_pvar)));
    }
}

rule ("[utilities/custom_hp.opy]: clearCustomHp()") {
    event {
        Subroutine;
        clearCustomHp;
    }
    actions {
        Remove All Health Pools From Player(Event Player);
        Wait(0.016, Ignore Condition);
        Set Max Health(Event Player, 100.001);
        Wait(0.016, Ignore Condition);
        Set Max Health(Event Player, 100);
    }
}

rule ("[utilities/custom_hp.opy]: applyCustomHp()") {
    event {
        Subroutine;
        applyCustomHp;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 3, 0);
        "loop MAX_HP_ITER_COUNT times if hp is incorrect"
        While(And(Or(Or(Compare(Absolute Value(Subtract(Max Health Of Type(Event Player, Health), First Of((Event Player).custom_hp_pvar))), >, 0.01), Compare(Absolute Value(Subtract(Max Health Of Type(Event Player, Armor), Value In Array((Event Player).custom_hp_pvar, 1))), >, 0.01)), Compare(Absolute Value(Subtract(Max Health Of Type(Event Player, Shields), Value In Array((Event Player).custom_hp_pvar, 2))), >, 0.01)), Compare(Value In Array((Event Player).custom_hp_pvar, 3), <, 10)));
            Set Healing Received(Event Player, 0);
            Wait Until(Has Spawned(Event Player), 999999999999999);
            Wait Until(Not(Or(Has Status(Event Player, Invincible), Has Status(Event Player, Unkillable))), 999999999999999);
            Wait(0.016, Ignore Condition);
            Set Player Health(Event Player, 1);
            Add Health Pool To Player(Event Player, Health, 1, True, True);
            Add Health Pool To Player(Event Player, Armor, 1, True, True);
            Add Health Pool To Player(Event Player, Shields, 1, True, True);
            "Apply an unkillable status so we don't accidentally kill the player"
            Set Status(Event Player, Event Player, Unkillable, 999999999999999);
            Remove All Health Pools From Player(Event Player);
            "wait(0.064)"
            Wait(0.016, Ignore Condition);
            Wait Until(Compare(Max Health(Event Player), <=, 1), 1);
            "Apply custom health pool to player"
            If(Compare(First Of((Event Player).custom_hp_pvar), >, 0));
                Add Health Pool To Player(Event Player, Health, Max(1, Subtract(First Of((Event Player).custom_hp_pvar), 1)), True, True);
            End;
            If(Compare(Value In Array((Event Player).custom_hp_pvar, 1), >, 0));
                Add Health Pool To Player(Event Player, Armor, Max(1, Value In Array((Event Player).custom_hp_pvar, 1)), True, True);
            End;
            If(Compare(Value In Array((Event Player).custom_hp_pvar, 2), >, 0));
                Add Health Pool To Player(Event Player, Shields, Max(1, Value In Array((Event Player).custom_hp_pvar, 2)), True, True);
            End;
            Set Healing Received(Event Player, 100);
            Heal(Event Player, Null, 999999999999999);
            Clear Status(Event Player, Unkillable);
            Wait(0.016, Ignore Condition);
            Modify Player Variable At Index(Event Player, custom_hp_pvar, 3, Add, 1);
        End;
    }
}

rule ("[utilities/reset.opy]: enableAllAbilities()") {
    event {
        Subroutine;
        enableAllAbilities;
    }
    actions {
        Allow Button(Event Player, Button(Primary Fire));
        Allow Button(Event Player, Button(Secondary Fire));
        Allow Button(Event Player, Button(Ability 1));
        Allow Button(Event Player, Button(Ability 2));
        Allow Button(Event Player, Button(Ultimate));
        Allow Button(Event Player, Button(Melee));
        Allow Button(Event Player, Button(Jump));
        Allow Button(Event Player, Button(Crouch));
        Allow Button(Event Player, Button(Reload));
        Allow Button(Event Player, Button(Interact));
        Set Primary Fire Enabled(Event Player, True);
        Set Secondary Fire Enabled(Event Player, True);
        Set Ability 1 Enabled(Event Player, True);
        Set Ability 2 Enabled(Event Player, True);
        Set Ultimate Ability Enabled(Event Player, True);
        Set Melee Enabled(Event Player, True);
        Set Jump Enabled(Event Player, True);
        Set Crouch Enabled(Event Player, True);
        Set Reload Enabled(Event Player, True);
    }
}

rule ("[utilities/reset.opy]: disableAllAbilities()") {
    event {
        Subroutine;
        disableAllAbilities;
    }
    actions {
        Disallow Button(Event Player, Button(Primary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Disallow Button(Event Player, Button(Ability 1));
        Disallow Button(Event Player, Button(Ability 2));
        Disallow Button(Event Player, Button(Ultimate));
        Disallow Button(Event Player, Button(Melee));
        Disallow Button(Event Player, Button(Jump));
        Disallow Button(Event Player, Button(Crouch));
        Disallow Button(Event Player, Button(Reload));
        Disallow Button(Event Player, Button(Interact));
        Set Primary Fire Enabled(Event Player, False);
        Set Secondary Fire Enabled(Event Player, False);
        Set Ability 1 Enabled(Event Player, False);
        Set Ability 2 Enabled(Event Player, False);
        Set Ultimate Ability Enabled(Event Player, False);
        Set Melee Enabled(Event Player, False);
        Set Jump Enabled(Event Player, False);
        Set Crouch Enabled(Event Player, False);
        Set Reload Enabled(Event Player, False);
    }
}

rule ("[utilities/reset.opy]: resetStats()") {
    event {
        Subroutine;
        resetStats;
    }
    actions {
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 1);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Damage Received(Event Player, 100);
        Set Projectile Speed(Event Player, 100);
        Set Projectile Gravity(Event Player, 100);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 1, 1);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 1)));
        Set Healing Received(Event Player, 100);
        Set Knockback Received(Event Player, 100);
        Set Knockback Dealt(Event Player, 100);
        Set Gravity(Event Player, 100);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 2, 1);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
    }
}

rule ("[utilities/reset.opy]: resetStatuses()") {
    event {
        Subroutine;
        resetStatuses;
    }
    actions {
        Clear Status(Event Player, Asleep);
        Clear Status(Event Player, Burning);
        Clear Status(Event Player, Frozen);
        Clear Status(Event Player, Hacked);
        Clear Status(Event Player, Invincible);
        Clear Status(Event Player, Knocked Down);
        Clear Status(Event Player, Phased Out);
        Clear Status(Event Player, Rooted);
        Clear Status(Event Player, Stunned);
        Clear Status(Event Player, Unkillable);
    }
}

rule ("[utilities/reset.opy]: resetFrenemies()") {
    event {
        Subroutine;
        resetFrenemies;
    }
    actions {
        Set Player Variable At Index(Event Player, reset_pvar, 2, First Of(Players On Hero(Hero(Orisa), Team Of(Event Player))));
        Set Player Variable At Index(Event Player, reset_pvar, 5, First Of(Players On Hero(Hero(Orisa), Opposite Team Of(Team Of(Event Player)))));
        Set Player Variable At Index(Event Player, reset_pvar, 3, First Of(Players On Hero(Hero(Sombra), Team Of(Event Player))));
        Set Player Variable At Index(Event Player, reset_pvar, 6, First Of(Players On Hero(Hero(Sombra), Opposite Team Of(Team Of(Event Player)))));
    }
}

rule ("[utilities/reset.opy]: Reinitialize hero on new round") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Between Rounds == True;
    }
    actions {
        Wait Until(Not(Is Between Rounds), 999999999999999);
        Call Subroutine(clearCustomHp);
        Call Subroutine(resetStats);
        Call Subroutine(resetStatuses);
        Call Subroutine(resetFrenemies);
        Call Subroutine(resetUltCharge);
        Call Subroutine(resetSelfHealing);
        Call Subroutine(enableAllAbilities);
        Set Player Variable At Index(Event Player, reset_pvar, 0, True);
    }
}

rule ("[passives/tank/ult_charge.opy]: resetUltCharge()") {
    event {
        Subroutine;
        resetUltCharge;
    }
    actions {
        Set Player Variable At Index(Event Player, ult_charge_pvar, 0, 0);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 0);
        Wait Until(Compare(Ultimate Charge Percent(Event Player), >, 0), 1);
        Set Ultimate Charge(Event Player, 0);
    }
}

rule ("[passives/tank/ult_charge.opy]: Remember missing ult charge from damaging tank") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Array Contains(All Tank Heroes, Hero Of(Victim)) == True;
        "Roadhog passive"
        Array Contains(Array(Hero(Roadhog)), Hero Of(Victim)) == False;
        Is Using Ultimate(Event Player) == False;
        Victim != Event Player;
    }
    actions {
        Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Add, Multiply(0.3, Event Damage));
    }
}

rule ("[passives/tank/ult_charge.opy]: Remember missing ult charge from healing tank") {
    event {
        Player Dealt Healing;
        All;
        All;
    }
    conditions {
        Array Contains(All Tank Heroes, Hero Of(Healee)) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Add, Multiply(0.3, Event Healing));
    }
}

rule ("[passives/tank/ult_charge.opy]: Compensate missing ultimate percentage") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Event Player).ult_charge_pvar) > Multiply(0.01, Value In Array((Event Player).ult_charge_pvar, 1));
        "guard to protect ult resetting accidentally"
        Value In Array((Event Player).ult_charge_pvar, 1) > 0;
    }
    actions {
        Set Player Variable At Index(Event Player, ult_charge_pvar, 2, Round To Integer(Multiply(100, Divide(Add(Multiply(Divide(Ultimate Charge Percent(Event Player), 100), Value In Array((Event Player).ult_charge_pvar, 1)), First Of((Event Player).ult_charge_pvar)), Value In Array((Event Player).ult_charge_pvar, 1))), Up));
        Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Subtract, Subtract(Multiply(Divide(Value In Array((Event Player).ult_charge_pvar, 2), 100), Value In Array((Event Player).ult_charge_pvar, 1)), Multiply(Divide(Ultimate Charge Percent(Event Player), 100), Value In Array((Event Player).ult_charge_pvar, 1))));
        Set Ultimate Charge(Event Player, Value In Array((Event Player).ult_charge_pvar, 2));
    }
}

rule ("[passives/tank/ult_charge.opy]: Reset ult compensation after using ult") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, ult_charge_pvar, 0, 0);
    }
}

rule ("[passives/support/self_heal.opy]: resetSelfHealing()") {
    event {
        Subroutine;
        resetSelfHealing;
    }
    actions {
        Stop Healing Modification(Value In Array((Event Player).self_heal_pvar, 2));
        Set Player Variable At Index(Event Player, self_heal_pvar, 2, Null);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        Set Player Variable At Index(Event Player, self_heal_pvar, 3, True);
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, False);
    }
}

rule ("[passives/support/self_heal.opy]: Detect healing passive") {
    event {
        Player Took Damage;
        All;
        All;
    }
    actions {
        Set Player Variable At Index(Event Player, self_heal_pvar, 3, False);
        "supports"
        If(Array Contains(All Support Heroes, Hero Of(Event Player)));
            Wait(2.484, Ignore Condition);
        "all other roles"
        Else;
            Wait(4.984, Ignore Condition);
        End;
        Set Player Variable At Index(Event Player, self_heal_pvar, 3, True);
    }
}

rule ("[passives/support/self_heal.opy]: Remove Passive self healing") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).self_heal_pvar, 5) != False;
        Value In Array((Event Player).self_heal_pvar, 3) != False;
        Health Of Type(Event Player, Shields) >= Max Health Of Type(Event Player, Shields);
        Health(Event Player) < Max Health(Event Player);
        Has Status(Event Player, Asleep) == False;
    }
    actions {
        Damage(Event Player, Null, 0.000001);
        Wait(If-Then-Else(Array Contains(All Support Heroes, Hero Of(Event Player)), 2.484, 4.984), Abort When False);
        Loop If Condition Is True;
    }
}

rule ("[utilities/hero_switch.opy]: detect hero switch") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Event Player).hero_switch_pvar) != Hero Of(Event Player);
    }
    actions {
        Set Player Variable At Index(Event Player, hero_switch_pvar, 1, True);
        Wait(0.016, Ignore Condition);
        Set Player Variable At Index(Event Player, hero_switch_pvar, 0, Hero Of(Event Player));
        Set Player Variable At Index(Event Player, hero_switch_pvar, 2, Index Of Array Value(All Heroes, First Of((Event Player).hero_switch_pvar)));
        Set Player Variable At Index(Event Player, hero_switch_pvar, 1, False);
    }
}

rule ("[utilities/hero_setup.opy]: Reset and initialize hero on hero switch") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).hero_switch_pvar, 1) != False;
    }
    actions {
        Wait Until(Has Spawned(Event Player), 999999999999999);
        Wait Until(Not(Value In Array((Event Player).hero_switch_pvar, 1)), 999999999999999);
        "wait(10 * TICK_DURATION)"
        Set Player Variable At Index(Event Player, reset_pvar, 7, Hero Of(Event Player));
        Call Subroutine(clearCustomHp);
        Call Subroutine(resetStats);
        Call Subroutine(resetStatuses);
        Call Subroutine(resetFrenemies);
        Call Subroutine(resetUltCharge);
        Call Subroutine(resetSelfHealing);
        Call Subroutine(enableAllAbilities);
        Set Player Variable At Index(Event Player, reset_pvar, 0, True);
    }
}

rule ("[utilities/ready.opy]: Create ready HUD") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is In Setup == True;
    }
    actions {
        If(Compare(First Of((Event Player).ready_hud), ==, Null));
            Create HUD Text(Event Player, Custom String("{0}/{1} ready", Count Of(Filtered Array(All Players(All Teams), Compare(First Of((Current Array Element).ready_pvar), ==, True))), Number Of Players(All Teams), Null), Custom String("Press {0} + {1} to ready", Input Binding String(Button(Interact)), Input Binding String(Button(Reload)), Null), Custom String("Overwatch 1++ Classic Developer Build (NC336)", Null, Null, Null), Top, 999999999999999, If-Then-Else(First Of((Event Player).ready_pvar), First Of(Global.reset_gvar), Color(Red)), Color(White), Color(White), String and Color, Default Visibility);
            Set Player Variable At Index(Event Player, ready_hud, 0, Last Text ID);
        End;
        If(Compare(Value In Array((Event Player).ready_hud, 1), ==, Null));
            Create HUD Text(Event Player, Null, Null, Custom String("Join Discord for Matchmaking", Null, Null, Null), Top, 999999999999999, Null, Null, Custom Color(250, 156, 29, 255), String and Color, Default Visibility);
            Set Player Variable At Index(Event Player, ready_hud, 1, Last Text ID);
        End;
        If(Compare(Value In Array((Event Player).ready_hud, 2), ==, Null));
            Create HUD Text(Event Player, Null, Null, Custom String("dsc.gg/runece", Null, Null, Null), Top, 999999999999999, Null, Null, Custom Color(141, 187, 9, 255), String and Color, Default Visibility);
            Set Player Variable At Index(Event Player, ready_hud, 2, Last Text ID);
        End;
        Wait Until(Not(Is In Setup), 999999999999999);
        For Player Variable(Event Player, ready_hud_i, 0, Count Of((Event Player).ready_hud), 1);
            Destroy HUD Text(Value In Array((Event Player).ready_hud, (Event Player).ready_hud_i));
            Set Player Variable At Index(Event Player, ready_hud, (Event Player).ready_hud_i, Null);
        End;
    }
}

rule ("[utilities/ready.opy]: Set initial ready color") {
    event {
        Ongoing - Global;
    }
    conditions {
        Is In Setup == True;
    }
    actions {
        Set Global Variable At Index(reset_gvar, 0, Color(Yellow));
    }
}

rule ("[utilities/ready.opy]: Unready all players when entering setup") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is In Setup == True;
    }
    actions {
        Set Player Variable At Index(Event Player, ready_pvar, 0, False);
    }
}

rule ("[utilities/ready.opy]: Toggle ready when pressing Interact + Reload") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is In Setup == True;
        Is Button Held(Event Player, Button(Interact)) == True;
        Is Button Held(Event Player, Button(Reload)) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, ready_pvar, 0, Not(First Of((Event Player).ready_pvar)));
    }
}

rule ("[utilities/ready.opy]: Start match when everyone ready") {
    event {
        Ongoing - Global;
    }
    conditions {
        Is In Setup == True;
        Match Time > 5;
        Divide(Count Of(Filtered Array(All Players(All Teams), First Of((Current Array Element).ready_pvar))), Number Of Players(All Teams)) >= Divide(Global.READY_THRESHOLD_PERCENT, 100);
        "Guard to prevent incorrect match time modification"
        Is Game In Progress == False;
        "Guard to prevent incorrect match time modification"
        Is Assembling Heroes == False;
    }
    actions {
        Set Global Variable At Index(reset_gvar, 0, Color(Green));
        Set Match Time(5);
    }
}

rule ("[utilities/ready.opy]: Reset ready when match starts") {
    event {
        Ongoing - Global;
    }
    conditions {
        Is Game In Progress == True;
    }
    actions {
        Set Player Variable At Index(All Players(All Teams), ready_pvar, 0, False);
    }
}

rule ("[utilities/hit_detection.opy]: findLineSphereIntersection()") {
    event {
        Subroutine;
        findLineSphereIntersection;
    }
    actions {
        Set Player Variable At Index(Event Player, hit_detection_pvar, 5, Subtract(Raise To Power(Absolute Value(Dot Product(Value In Array((Event Player).hit_detection_pvar, 3), Subtract(First Of((Event Player).hit_detection_pvar), Value In Array((Event Player).hit_detection_pvar, 1)))), 2), Subtract(Raise To Power(Distance Between(First Of((Event Player).hit_detection_pvar), Value In Array((Event Player).hit_detection_pvar, 1)), 2), Raise To Power(Value In Array((Event Player).hit_detection_pvar, 2), 2))));
        "line goes through sphere"
        If(Compare(Value In Array((Event Player).hit_detection_pvar, 5), >, 0));
            Set Player Variable At Index(Event Player, hit_detection_pvar, 4, Array(Subtract(Multiply(-1, Dot Product(Value In Array((Event Player).hit_detection_pvar, 3), Subtract(First Of((Event Player).hit_detection_pvar), Value In Array((Event Player).hit_detection_pvar, 1)))), Square Root(Value In Array((Event Player).hit_detection_pvar, 5))), Add(Multiply(-1, Dot Product(Value In Array((Event Player).hit_detection_pvar, 3), Subtract(First Of((Event Player).hit_detection_pvar), Value In Array((Event Player).hit_detection_pvar, 1)))), Square Root(Value In Array((Event Player).hit_detection_pvar, 5)))));
        "line tangent to sphere"
        Else If(Compare(Value In Array((Event Player).hit_detection_pvar, 5), ==, 0));
            Set Player Variable At Index(Event Player, hit_detection_pvar, 4, Array(Multiply(-1, Dot Product(Value In Array((Event Player).hit_detection_pvar, 3), Subtract(First Of((Event Player).hit_detection_pvar), Value In Array((Event Player).hit_detection_pvar, 1))))));
        "no intersection/solution"
        Else If(Compare(Value In Array((Event Player).hit_detection_pvar, 5), <, 0));
            Set Player Variable At Index(Event Player, hit_detection_pvar, 4, Empty Array);
        Else;
            Set Player Variable At Index(Event Player, hit_detection_pvar, 4, Empty Array);
        End;
        Set Player Variable At Index(Event Player, hit_detection_pvar, 6, Empty Array);
        For Player Variable(Event Player, lsi_i, 0, Count Of(Value In Array((Event Player).hit_detection_pvar, 4)), 1);
            If(Compare(Value In Array(Value In Array((Event Player).hit_detection_pvar, 4), (Event Player).lsi_i), >=, 0));
                Modify Player Variable At Index(Event Player, hit_detection_pvar, 6, Append To Array, Add(First Of((Event Player).hit_detection_pvar), Multiply(Value In Array(Value In Array((Event Player).hit_detection_pvar, 4), (Event Player).lsi_i), Value In Array((Event Player).hit_detection_pvar, 3))));
            End;
        End;
    }
}

rule ("[utilities/anti_crash.opy]: Activate anti crash") {
    event {
        Ongoing - Global;
    }
    conditions {
        Server Load > Global.ANTI_CRASH_ACTIVATE_PERCENT;
    }
    actions {
        Wait(Global.ANTI_CRASH_HOLD_TIME, Abort When False);
        Small Message(All Players(All Teams), Custom String("Anti crash system activated", Null, Null, Null));
        Set Slow Motion(1);
        Wait(0.5, Ignore Condition);
        Wait Until(Compare(Server Load, <, Global.ANTI_CRASH_DEACTIVATE_PERCENT), 999999999999999);
        Set Slow Motion(100);
    }
}

rule ("[ana/sleep.opy]: Sleep tanks for longer duration") {
    event {
        Player Dealt Damage;
        All;
        Ana;
    }
    conditions {
        Event Ability == Button(Ability 1);
        Array Contains(All Tank Heroes, Hero Of(Victim)) == True;
    }
    actions {
        Set Player Variable At Index(Victim, sleep_pvar, 0, Total Time Elapsed);
        Wait Until(Has Status(Victim, Asleep), 999999999999999);
        Set Player Variable At Index(Victim, sleep_pvar, 1, True);
        Wait(0.5, Ignore Condition);
        Clear Status(Victim, Asleep);
        Set Status(Victim, Null, Knocked Down, 4.5);
        Wait(4.5, Ignore Condition);
        Set Player Variable At Index(Victim, sleep_pvar, 1, False);
    }
}

rule ("[ana/sleep.opy]: Wake sleeping tank if damage taken after MIN_SLEEP_DURATION") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        Value In Array((Victim).sleep_pvar, 1) != False;
        Has Status(Victim, Asleep) == False;
        Array Contains(All Tank Heroes, Hero Of(Victim)) == True;
        Subtract(Total Time Elapsed, First Of((Victim).sleep_pvar)) > 0.5;
        Or(And(Compare(Hero Of(Attacker), ==, Hero(Sigma)), Compare(Event Ability, ==, Button(Ability 2))), And(Compare(Hero Of(Attacker), ==, Hero(Reinhardt)), Compare(Event Ability, ==, Button(Ultimate)))) == False;
    }
    actions {
        Clear Status(Victim, Knocked Down);
        Set Player Variable At Index(Event Player, sleep_pvar, 1, False);
    }
}

rule ("[ana/nade.opy]: Heal launch healing with biotic grenade") {
    event {
        Player Dealt Healing;
        All;
        Ana;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Heal(Healee, Healer, Subtract(Multiply(Event Healing, 1.388888888888888), Event Healing));
    }
}

rule ("[ana/nade.opy]: Allow self healing during Biotic Grenade") {
    event {
        Ongoing - Each Player;
        All;
        Ana;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        If(Not(Array Contains(First Of((Event Player).self_heal_pvar), Button(Ability 2))));
            Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Append To Array, Button(Ability 2));
        End;
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999999999999);
        Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Remove From Array By Value, Button(Ability 2));
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
    }
}

rule ("[ana/boost.opy]: set nano boost speed") {
    event {
        Ongoing - Each Player;
        All;
        Ana;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, nano_boost_speed, Player Closest To Reticle(Event Player, Team Of(Event Player)));
        Set Move Speed((Event Player).nano_boost_speed, Multiply(100, Multiply(1.3, Value In Array((Event Player).stat_helper_pvar, 2))));
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Set Move Speed((Event Player).nano_boost_speed, 100);
    }
}

rule ("[ana/init.opy]: Initialize Ana") {
    event {
        Ongoing - Each Player;
        All;
        Ana;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2100);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Ammo(Event Player, 0, 6);
        Set Max Ammo(Event Player, 0, 6);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 1.111111111111111);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[ana/init.opy]: Correct rifle and sleep dart damage") {
    event {
        Player Dealt Damage;
        All;
        Ana;
    }
    conditions {
        Array Contains(Array(Button(Primary Fire), Button(Ability 1)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[ashe/bob.opy]: Add ultimate charge while using BOB") {
    event {
        Ongoing - Each Player;
        All;
        Ashe;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, ult_point_while_ult_active, 0);
        Set Player Variable(Event Player, start_time_ult, Total Time Elapsed);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        "Check if the user did not switch hero after using B.O.B to add the ult charge"
        If(Compare(Hero Of(Event Player), ==, Hero(Ashe)));
            "Add charge for passive generation and then the ult charge generated from the damage made by Ashe"
            Set Player Variable At Index(Event Player, ult_charge_pvar, 0, Add(Multiply(5, Subtract(Total Time Elapsed, (Event Player).start_time_ult)), (Event Player).ult_point_while_ult_active));
    }
}

rule ("[ashe/bob.opy]: Calcul of the damage made while BOB is active") {
    event {
        Player Dealt Damage;
        All;
        Ashe;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Victim != Attacker;
    }
    actions {
        If(Array Contains(All Tank Heroes, Hero Of(Victim)));
            Modify Player Variable(Event Player, ult_point_while_ult_active, Add, Multiply(1.3, Event Damage));
        Else;
            Modify Player Variable(Event Player, ult_point_while_ult_active, Add, Event Damage);
    }
}

rule ("[ashe/init.opy]: Initialize Ashe") {
    event {
        Ongoing - Each Player;
        All;
        Ashe;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2240);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 0.941176470588235);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[ashe/init.opy]: Compensate Ashe global damage reduction") {
    event {
        Player Dealt Damage;
        All;
        Ashe;
    }
    conditions {
        Array Contains(Array(Button(Primary Fire), Button(Ability 1), Button(Ability 2)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[baptiste/regen_burst.opy]: Remove initial burst healing from regenerative burst") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Healing Dealt(Event Player, 0);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Set Healing Dealt(Event Player, 100);
    }
}

rule ("[baptiste/regen_burst.opy]: Allow self healing during regenerative burst") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        If(Not(Array Contains(First Of((Event Player).self_heal_pvar), Button(Ability 1))));
            Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Append To Array, Button(Ability 1));
        End;
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
        Wait(5, Restart When True);
        Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Remove From Array By Value, Button(Ability 1));
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
    }
}

rule ("[baptiste/regen_burst.opy]: ow1 regenerative burst hps") {
    event {
        Player Dealt Healing;
        All;
        Baptiste;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        "self healing"
        If(Compare(Healee, ==, Healer));
            Heal(Healee, Healer, Subtract(Multiply(Divide(Event Healing, Value In Array((Event Player).stat_helper_pvar, 1)), 3.5), Event Healing));
        "ally healing"
        Else;
            Heal(Healee, Healer, Subtract(Multiply(Divide(Event Healing, Value In Array((Event Player).stat_helper_pvar, 1)), 1.5), Event Healing));
    }
}

rule ("[baptiste/init.opy]: Initialize Baptiste") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2310);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 1.2);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Ammo(Event Player, 0, 45);
        Set Max Ammo(Event Player, 0, 45);
        Set Ammo(Event Player, 1, 16);
        Set Max Ammo(Event Player, 1, 16);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("startFiring()") {
    event {
        Subroutine;
        startFiring;
    }
    actions {
        If(Is Button Held(Event Player, Button(Primary Fire)));
            Start Holding Button(Event Player, Button(Primary Fire));
            Wait Until(Not(Is Button Held(Event Player, Button(Primary Fire))), 999999999999999);
            Stop Holding Button(Event Player, Button(Primary Fire));
        End;
    }
}

rule ("[bastion/sentry.opy]: Initialize sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is In Alternate Form(Event Player) == True;
        "Sentry mode can only be entered from recon mode"
        (Event Player).current_configuration == 0;
        "prevents incorrectly identifying tank as sentry"
        (Event Player).current_configuration != 2;
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, current_configuration, 1);
        Set Primary Fire Enabled(Event Player, False);
        Disallow Button(Event Player, Button(Secondary Fire));
        Set Damage Received(Event Player, 125);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 1.25);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Status(Event Player, Null, Rooted, 999999999999999);
        Set Knockback Received(Event Player, 0);
        Wait(0.5, Ignore Condition);
        If(Is Using Ability 1(Event Player));
            Disallow Button(Event Player, Button(Ability 1));
            Set Primary Fire Enabled(Event Player, False);
            Wait(0.5, Ignore Condition);
            Allow Button(Event Player, Button(Ability 1));
            Set Primary Fire Enabled(Event Player, True);
            Call Subroutine(startFiring);
        End;
        Wait Until(Is On Ground(Event Player), 999999999999999);
        If(Compare((Event Player).current_configuration, ==, 1));
            Set Move Speed(Event Player, 0);
    }
}

rule ("[bastion/sentry.opy]: Extend sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
        (Event Player).current_configuration != 2;
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait(1, Ignore Condition);
        "6 second total time - 1 second - 1 tick"
        Wait Until(Not(Is Using Ability 1(Event Player)), 4.984);
        Wait Until(Or(Is Button Held(Event Player, Button(Ability 1)), Not(Is Using Ability 1(Event Player))), 1);
        If(And(Is Using Ability 1(Event Player), Not(Is Button Held(Event Player, Button(Ability 1)))));
            Wait(0.016, Ignore Condition);
            Cancel Primary Action(Event Player);
            Press Button(Event Player, Button(Ability 1));
            Set Knockback Received(Event Player, 0);
            Set Status(Event Player, Null, Rooted, 999999999999999);
            Wait Until(Is On Ground(Event Player), 999999999999999);
            Set Move Speed(Event Player, 0);
        End;
        Loop If Condition Is True;
    }
}

rule ("[bastion/sentry.opy]: Stop using sentry if player dealt cc") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
        (Event Player).current_configuration != 2;
        Is Using Ability 1(Event Player) == True;
        Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)) == True;
    }
    actions {
        Wait Until(Not(Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down))), 999999999999999);
        Press Button(Event Player, Button(Ability 1));
    }
}

rule ("[bastion/recon.opy]: Initialize recon mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        "built in workshop function for detecting default hero form"
        Is In Alternate Form(Event Player) == False;
    }
    actions {
        Set Player Variable(Event Player, current_configuration, 0);
        Set Move Speed(Event Player, 100);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 1);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Damage Received(Event Player, 100);
        Set Projectile Speed(Event Player, 100);
        Set Projectile Gravity(Event Player, 100);
        Allow Button(Event Player, Button(Primary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Clear Status(Event Player, Rooted);
        Set Knockback Received(Event Player, 100);
        If(Is Button Held(Event Player, Button(Primary Fire)));
            Stop Holding Button(Event Player, Button(Primary Fire));
    }
}

rule ("[bastion/tank.opy]: Initialize tank mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, current_configuration, 2);
        "move faster in tank mode"
        Set Move Speed(Event Player, 153.84615384615384);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 2.5);
        "deal more damage in tank mode"
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        "increase grenade travel speed (to mimic tank shells)"
        Set Projectile Speed(Event Player, 150);
        Set Projectile Gravity(Event Player, 5);
        "Disallow firing machine gun"
        Disallow Button(Event Player, Button(Primary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Clear Status(Event Player, Rooted);
        Set Knockback Received(Event Player, 100);
        "transform into ow1 tank\nPrevent Bastion from getting ult charge during ultimate"
        Set Ultimate Ability Enabled(Event Player, False);
        Wait(0.5, Ignore Condition);
        "interrupt ultimate animation right before it completes"
        Cancel Primary Action(Event Player);
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
        "Go to turret mode"
        Press Button(Event Player, Button(Ability 1));
        "Disable reconfiguring out of turret mode"
        Disallow Button(Event Player, Button(Ability 1));
        Wait Until(Not(Is Using Ability 1(Event Player)), 8);
        If(Is Using Ability 1(Event Player));
            Set Ability Cooldown(Event Player, Button(Ability 1), 0);
            "Go to recon mode"
            Press Button(Event Player, Button(Ability 1));
        End;
        Allow Button(Event Player, Button(Ability 1));
        Set Ultimate Ability Enabled(Event Player, True);
    }
}

rule ("[bastion/tank.opy]: Fire tank shells") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 2;
        Is Button Held(Event Player, Button(Primary Fire)) == True;
    }
    actions {
        Allow Button(Event Player, Button(Secondary Fire));
        Press Button(Event Player, Button(Secondary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Wait(0.016, Ignore Condition);
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Secondary Fire)), <=, 0), 999999999999999);
        Loop If Condition Is True;
    }
}

rule ("[bastion/tank.opy]: Reload tank shells") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 2;
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        "modify cooldown for tank shell"
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 0.75);
        "Wait tank shell reload time"
        Wait(0.75, Ignore Condition);
        "Set tank shell as available"
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
    }
}

rule ("[bastion/repair.opy]: Activate self-repair") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == True;
        Is Firing Primary(Event Player) == False;
        Is Meleeing(Event Player) == False;
        Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)) == False;
        Is Alive(Event Player) == True;
        (Event Player).self_repair_time_left > 0;
    }
    actions {
        Wait(0.7, Abort When False);
        Set Status(Event Player, Null, Rooted, 999999999999999);
        "repair sparks and ring vfx"
        If(Compare(Value In Array((Event Player).repair_pvar, 2), ==, Null));
            Create Effect(All Players(All Teams), Sparkles, Color(Yellow), Update Every Frame(Eye Position(Event Player)), 1.5, Visible To Position and Radius);
            Set Player Variable At Index(Event Player, repair_pvar, 2, Last Created Entity);
        End;
        If(Compare(Value In Array((Event Player).repair_pvar, 3), ==, Null));
            Create Effect(All Players(All Teams), Sparkles, Color(Yellow), Update Every Frame(Divide(Add(Eye Position(Event Player), Position Of(Event Player)), 2)), 1.5, Visible To Position and Radius);
            Set Player Variable At Index(Event Player, repair_pvar, 3, Last Created Entity);
        End;
        If(Compare(Value In Array((Event Player).repair_pvar, 4), ==, Null));
            Create Effect(All Players(All Teams), Light Shaft, Color(Yellow), Update Every Frame(Position Of(Event Player)), 1.5, Visible To Position and Radius);
            Set Player Variable At Index(Event Player, repair_pvar, 4, Last Created Entity);
        End;
        If(Compare(First Of((Event Player).repair_pvar), ==, Null));
            Start Heal Over Time(Event Player, Event Player, 999999999999999, 90);
            Set Player Variable At Index(Event Player, repair_pvar, 0, Last Heal Over Time ID);
    }
}

rule ("[bastion/repair.opy]: Deactivate self-repair if player took damage") {
    event {
        Player Took Damage;
        All;
        Bastion;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == True;
        Is Firing Primary(Event Player) == False;
        Is Meleeing(Event Player) == False;
        Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)) == False;
        Is Alive(Event Player) == True;
        (Event Player).self_repair_time_left > 0;
    }
    actions {
        "Stop healing"
        Stop Heal Over Time(First Of((Event Player).repair_pvar));
        Set Player Variable At Index(Event Player, repair_pvar, 0, Null);
        Clear Status(Event Player, Rooted);
        Destroy Effect(Value In Array((Event Player).repair_pvar, 2));
        Set Player Variable At Index(Event Player, repair_pvar, 2, Null);
        Destroy Effect(Value In Array((Event Player).repair_pvar, 3));
        Set Player Variable At Index(Event Player, repair_pvar, 3, Null);
        Destroy Effect(Value In Array((Event Player).repair_pvar, 4));
        Set Player Variable At Index(Event Player, repair_pvar, 4, Null);
    }
}

rule ("[bastion/repair.opy]: Deactivate self-repair") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration != 1;
        Or(Or(Is Button Held(Event Player, Button(Ability 2)), Is Firing Primary(Event Player)), Not(Has Status(Event Player, Rooted))) == True;
    }
    actions {
        "Stop healing"
        Stop Heal Over Time(First Of((Event Player).repair_pvar));
        Set Player Variable At Index(Event Player, repair_pvar, 0, Null);
        Destroy Effect(Value In Array((Event Player).repair_pvar, 2));
        Set Player Variable At Index(Event Player, repair_pvar, 2, Null);
        Destroy Effect(Value In Array((Event Player).repair_pvar, 3));
        Set Player Variable At Index(Event Player, repair_pvar, 3, Null);
        Destroy Effect(Value In Array((Event Player).repair_pvar, 4));
        Set Player Variable At Index(Event Player, repair_pvar, 4, Null);
        Clear Status(Event Player, Rooted);
        "Wait 1 second cooldown before recharging heal resource"
        Wait(0.7, Abort When False);
        "Start recharging"
        Chase Player Variable At Rate(Event Player, self_repair_time_left, 3.333333333333333, 0.476190476190476, Destination and Rate);
    }
}

rule ("[bastion/repair.opy]: Give ult charge for self repair") {
    event {
        Player Dealt Healing;
        All;
        Bastion;
    }
    conditions {
        Healer == Healee;
    }
    actions {
        Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Add, Event Healing);
    }
}

rule ("[bastion/machine_gun.opy]: Activate machine gun in sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
    }
    actions {
        Set Player Variable(Event Player, machine_gun_ready, True);
        Stop Chasing Player Variable(Event Player, machine_gun_reload_timer);
        "show machine gun ammo"
        If(Compare((Event Player).machine_gun_ammo_id, ==, Null));
            Create In-World Text(Event Player, Custom String("{0}|{1}", Round To Integer((Event Player).machine_gun_ammo, Up), 200, Null), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(3.3, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.5, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 2, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
            Set Player Variable(Event Player, machine_gun_ammo_id, Last Text ID);
    }
}

rule ("[bastion/machine_gun.opy]: Hide machine gun ammo when not in sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration != 1;
    }
    actions {
        Destroy In-World Text((Event Player).machine_gun_ammo_id);
        Set Player Variable(Event Player, machine_gun_ammo_id, Null);
    }
}

rule ("[bastion/machine_gun.opy]: start machine gun reload timer") {
    event {
        Subroutine;
        reloadMachineGun;
    }
    actions {
        Set Player Variable(Event Player, machine_gun_reload_timer, 1.984);
        Chase Player Variable At Rate(Event Player, machine_gun_reload_timer, 0, 1, Destination and Rate);
    }
}

rule ("[bastion/machine_gun.opy]: finish reloading machine gun") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).machine_gun_reload_timer <= 0;
    }
    actions {
        Set Player Variable(Event Player, machine_gun_ammo, 200);
        Set Ammo(Event Player, 1, 200);
    }
}

rule ("[bastion/machine_gun.opy]: Consume machine gun ammo when shooting") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
        Is Firing Primary(Event Player) == True;
    }
    actions {
        Chase Player Variable At Rate(Event Player, machine_gun_ammo, 0, 30, Destination and Rate);
    }
}

rule ("[bastion/machine_gun.opy]: Stop machine gun ammo consumption when not shooting") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        And(Compare((Event Player).current_configuration, ==, 1), Is Firing Primary(Event Player)) == False;
    }
    actions {
        Stop Chasing Player Variable(Event Player, machine_gun_ammo);
    }
}

rule ("[bastion/machine_gun.opy]: Reload machine gun on reload key or when out of ammo") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Or(Is Button Held(Event Player, Button(Reload)), Compare((Event Player).machine_gun_ammo, <=, 0)) == True;
        (Event Player).current_configuration == 1;
        Is Reloading(Event Player) == False;
        "don't reload if ammo already full"
        (Event Player).machine_gun_ammo < 200;
    }
    actions {
        "play turret reload animation"
        Set Ammo(Event Player, 1, 0);
        Call Subroutine(reloadMachineGun);
    }
}

rule ("[bastion/machine_gun.opy]: Reload machine gun when not in sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration != 1;
    }
    actions {
        Call Subroutine(reloadMachineGun);
    }
}

rule ("[bastion/machine_gun.opy]: Allow machine gun shooting when machine gun ready") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        "gun ready to shoot"
        (Event Player).machine_gun_ready != False;
        (Event Player).current_configuration == 1;
    }
    actions {
        Allow Button(Event Player, Button(Primary Fire));
    }
}

rule ("[bastion/machine_gun.opy]: Disallow machine gun shooting when machine gun not ready") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        "gun not ready to shoot"
        (Event Player).machine_gun_ready == False;
        (Event Player).current_configuration == 1;
    }
    actions {
        Disallow Button(Event Player, Button(Primary Fire));
    }
}

rule ("[bastion/init.opy]: Initialize Bastion") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 100);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2310);
        Set Player Variable(Event Player, machine_gun_ammo, 200);
        Set Player Variable(Event Player, machine_gun_reload_timer, 0);
        Set Max Ammo(Event Player, 0, 20);
        Set Ammo(Event Player, 0, 20);
        Disallow Button(Event Player, Button(Secondary Fire));
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[bastion/init.opy]: Clean up Bastion") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Bastion);
    }
    actions {
        Wait Until(Compare(Hero Of(Event Player), !=, Hero(Bastion)), 999999999999999);
        Destroy In-World Text((Event Player).machine_gun_ammo_id);
        Set Player Variable(Event Player, machine_gun_ammo_id, Null);
        Destroy Effect(Value In Array((Event Player).repair_pvar, 2));
        Set Player Variable At Index(Event Player, repair_pvar, 2, Null);
        Destroy Effect(Value In Array((Event Player).repair_pvar, 3));
        Set Player Variable At Index(Event Player, repair_pvar, 3, Null);
        Destroy Effect(Value In Array((Event Player).repair_pvar, 4));
        Set Player Variable At Index(Event Player, repair_pvar, 4, Null);
    }
}

rule ("[brigitte/bash.opy]: Add stun to shield bash") {
    event {
        Player Dealt Damage;
        All;
        Brigitte;
    }
    conditions {
        Is Firing Secondary(Attacker) == True;
        Event Ability == Button(Primary Fire);
    }
    actions {
        "@Condition not attacker.shield_bash_through_barrier"
        Set Status(Victim, Attacker, Stunned, 1);
    }
}

rule ("[brigitte/bash.opy]: Reduce shield bash distance") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Is Firing Primary(Event Player) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        "arbitrarily decided based on trial and error"
        Set Move Speed(Event Player, 77.8);
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Primary Fire)), >, 0), 999999999999999);
        If(Is Using Ultimate(Event Player));
            Set Move Speed(Event Player, 113.04347826086958);
        Else;
            Set Move Speed(Event Player, 100);
    }
}

rule ("[brigitte/bash.opy]: Reduce shield bash damage to OW1") {
    event {
        Player Dealt Damage;
        All;
        Brigitte;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Event Ability == Button(Primary Fire);
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Multiply(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), 0.4)));
    }
}

rule ("[brigitte/repair.opy]: Only one repair") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 2(Event Player)), 1);
        Set Ability Charge(Event Player, Button(Ability 2), 0);
        Wait(6, Ignore Condition);
        Set Ability Charge(Event Player, Button(Ability 2), 3);
    }
}

rule ("[brigitte/repair.opy]: disable repair if 20m") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        Distance Between(Event Player, Player Closest To Reticle(Event Player, Team Of(Event Player))) >= 20;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 2));
    }
}

rule ("[brigitte/repair.opy]: enable repair if under 20m") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        Distance Between(Event Player, Player Closest To Reticle(Event Player, Team Of(Event Player))) <= 20;
    }
    actions {
        Allow Button(Event Player, Button(Ability 2));
    }
}

rule ("[brigitte/repair.opy]: repair instant heal") {
    event {
        Player Received Healing;
        All;
        All;
    }
    conditions {
        Hero Of(Healer) == Hero(Brigitte);
        Event Ability == Button(Ability 2);
        Normalized Health(Event Player) < 1;
    }
    actions {
        Heal(Event Player, Healer, 150);
    }
}

rule ("[brigitte/repair.opy]: repair bonus armor") {
    event {
        Player Received Healing;
        All;
        All;
    }
    conditions {
        Hero Of(Healer) == Hero(Brigitte);
        Event Ability == Button(Ability 2);
        Normalized Health(Event Player) == 1;
    }
    actions {
        Add Health Pool To Player(Event Player, Health, 75, False, False);
        Set Player Variable(Event Player, repair_pack_armor, Last Created Health Pool);
        Wait(5, Ignore Condition);
        Remove Health Pool From Player(Last Created Health Pool);
    }
}

rule ("[brigitte/rally.opy]: rally start") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Call Subroutine(startRally);
        Wait Until(Not(Is Using Ultimate(Event Player)), 10);
        Call Subroutine(endRally);
    }
}

rule ("[brigitte/rally.opy]: startRally()") {
    event {
        Subroutine;
        startRally;
    }
    actions {
        Set Player Variable At Index(Event Player, rally_pvar, 0, True);
        Set Player Variable At Index(Event Player, rally_pvar, 3, 0.1);
        "604 is the least amount i could do, sorry i tried."
        Set Max Health(Event Player, Value In Array((Event Player).rally_pvar, 3));
        "Set brig barrier scale"
        Start Scaling Barriers(Event Player, 0.75, False);
        "30% movement speed buff during rally"
        Set Move Speed(Event Player, 113.04347826086958);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 100);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        "Remove Rally instant armor"
        Damage(Event Player, Null, 50);
        Start Heal Over Time(Event Player, Null, 999999999999999, 15);
        Set Player Variable(Event Player, rally_hot_id, Last Heal Over Time ID);
    }
}

rule ("[brigitte/rally.opy]: endRally()") {
    event {
        Subroutine;
        endRally;
    }
    actions {
        Stop Scaling Barriers(Event Player);
        Set Player Variable At Index(Event Player, rally_pvar, 1, Health Of Type(Event Player, Health));
        Set Player Variable At Index(Event Player, rally_pvar, 2, Health Of Type(Event Player, Armor));
        "Keep this on for correct regenaration https://us.forums.blizzard.com/en/overwatch/t/shield-health-recharge/588713"
        Set Max Health(Event Player, 100);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 50);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Health(Event Player, Add(Min(200, Value In Array((Event Player).rally_pvar, 1)), Value In Array((Event Player).rally_pvar, 2)));
        Set Move Speed(Event Player, 100);
        Stop Heal Over Time((Event Player).rally_hot_id);
        Set Player Variable At Index(Event Player, rally_pvar, 0, False);
    }
}

rule ("[brigitte/rally.opy]: Reset rally if player died") {
    event {
        Player Died;
        All;
        All;
    }
    conditions {
        First Of((Event Player).rally_pvar) != False;
    }
    actions {
        Wait Until(Is Alive(Event Player), 999999999999999);
        Call Subroutine(endRally);
    }
}

rule ("[brigitte/inspire.opy]: Inspire self healing logic") {
    event {
        Player Dealt Damage;
        All;
        Brigitte;
    }
    actions {
        If(Not(Array Contains(First Of((Event Player).self_heal_pvar), Button(Melee))));
            Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Append To Array, Button(Melee));
        End;
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
        Wait(5, Restart When True);
        Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Remove From Array By Value, Button(Melee));
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
    }
}

rule ("[brigitte/init.opy]: Initialize Brigitte") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 50);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1900);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 0.666666666666666);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[brigitte/init.opy]: Clean up brigitte") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Brigitte);
    }
    actions {
        Wait Until(Compare(Hero Of(Event Player), !=, Hero(Brigitte)), 999999999999999);
        Call Subroutine(endRally);
    }
}

rule ("[brigitte/init.opy]: Compensate Brigitte global damage reduction") {
    event {
        Player Dealt Damage;
        All;
        Brigitte;
    }
    conditions {
        Array Contains(Array(Button(Ability 1)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[cassidy/fan_hammer.opy]: Launch Fan the Hammer damage") {
    event {
        Player Dealt Damage;
        All;
        Cassidy;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.111111111111111), Event Damage));
    }
}

rule ("[cassidy/flashbang.opy]: OW1 flashbang") {
    event {
        Player Dealt Damage;
        All;
        Cassidy;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Set Player Variable At Index(Event Player, flashbang_pvar, 0, False);
        Set Status(Victim, Event Player, Stunned, 0.8);
        Heal(Victim, Null, 20);
        Set Move Speed(Victim, 200);
        Wait(1.2, Ignore Condition);
        Set Move Speed(Victim, 100);
    }
}

rule ("[cassidy/roll.opy]: Remove damage reduction during roll") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Damage Received(Event Player, 200);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Set Damage Received(Event Player, 100);
    }
}

rule ("[cassidy/deadeye.opy]: OW1 deadeye damage + remove OW2 damage reduction during deadeye") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 166.66666666666669);
        Set Damage Received(Event Player, 166.66666666666669);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Damage Received(Event Player, 100);
    }
}

rule ("[cassidy/init.opy]: Initialize Cassidy") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1800);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1800);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[doomfist/uppercut.opy]: Control flow for uppercut") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
        Is Using Ability 1(Event Player) == False;
        Is Firing Secondary(Event Player) == False;
    }
    actions {
        "cancel Power Block animation"
        Cancel Primary Action(Event Player);
        Set Ability 2 Enabled(Event Player, False);
        Set Ability Cooldown(Event Player, Button(Ability 2), 0);
        "Execute Uppercut\nStart of uppercut"
        Set Player Variable(Event Player, is_using_uppercut, True);
        "Disable abilities during uppercut"
        Set Player Variable At Index(Event Player, uppercut_pvar, 1, True);
        "Doomfist cannot melee during uppercut"
        Set Melee Enabled(Event Player, False);
        "Doomfist cannot shoot during uppercut"
        Set Primary Fire Enabled(Event Player, False);
        "Doomfist cannot punch during uppercut"
        Set Secondary Fire Enabled(Event Player, False);
        "Doomfist cannot slam during uppercut"
        Set Ability 1 Enabled(Event Player, False);
        "Doomfist cannot ult during uppercut"
        Disallow Button(Event Player, Button(Ultimate));
        Wait(0.6, Ignore Condition);
        "Reenable abilities"
        Set Player Variable At Index(Event Player, uppercut_pvar, 1, False);
        Set Melee Enabled(Event Player, True);
        Set Primary Fire Enabled(Event Player, True);
        "Shoot single buffered left click interrupted by power block"
        If(Is Button Held(Event Player, Button(Primary Fire)));
            Press Button(Event Player, Button(Primary Fire));
        End;
        Set Secondary Fire Enabled(Event Player, True);
        Set Ability 1 Enabled(Event Player, True);
        Allow Button(Event Player, Button(Ultimate));
        "Activate ult if button held"
        If(Is Button Held(Event Player, Button(Ultimate)));
            Press Button(Event Player, Button(Ultimate));
    }
}

rule ("[doomfist/uppercut.opy]: Uppercut vfx + movement physics") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).is_using_uppercut != False;
    }
    actions {
        "vfx"
        Play Effect(All Players(All Teams), Explosion Sound, Team Of(Event Player), Event Player, 100);
        Play Effect(All Players(All Teams), Debuff Impact Sound, Team Of(Event Player), Event Player, 100);
        Play Effect(All Players(All Teams), Ring Explosion Sound, Team Of(Event Player), Event Player, 100);
        "movement physics"
        Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
        "Doomfist phases through enemies during uppercut"
        Disable Movement Collision With Players(Event Player);
        "Step Forward"
        Apply Impulse(Event Player, World Vector Of(Forward, Event Player, Rotation), 5, To World, Incorporate Contrary Motion);
        "Override gravity during uppercut"
        Set Gravity(Event Player, 0);
        "Deny player from inputting movement commands"
        Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
        Wait(0.15, Ignore Condition);
        "Uppercut"
        Apply Impulse(Event Player, Up, 40, To World, Incorporate Contrary Motion);
        Wait(0.1, Ignore Condition);
        Apply Impulse(Event Player, Down, Max(0, Speed Of In Direction(Event Player, Up)), To World, Incorporate Contrary Motion);
        Wait(0.016, Ignore Condition);
        Apply Impulse(Event Player, Up, 2.5, To World, Incorporate Contrary Motion);
        Enable Movement Collision With Players(Event Player);
        "End of uppercut"
        Set Player Variable(Event Player, is_using_uppercut, False);
        Wait(0.35, Ignore Condition);
        "set cooldown"
        Set Ability Cooldown(Event Player, Button(Ability 2), Global.DOOMFIST_UPPERCUT_COOLDOWN);
        Set Ability 2 Enabled(Event Player, True);
        Stop Forcing Throttle(Event Player);
        Wait(0.15, Ignore Condition);
        Abort If(Is Using Ability 1(Event Player));
        Set Gravity(Event Player, 50);
        Wait(0.25, Ignore Condition);
        Abort If(Is Using Ability 1(Event Player));
        Set Gravity(Event Player, 100);
    }
}

rule ("[doomfist/uppercut.opy]: Detect uppercut victims") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).is_using_uppercut != False;
        Is Alive(Event Player) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, uppercut_pvar, 4, Remove From Array(Players Within Radius(Event Player, 5, Opposite Team Of(Team Of(Event Player)), Surfaces), Event Player));
        "Victim in front of doomfist"
        Set Player Variable At Index(Event Player, uppercut_pvar, 4, Filtered Array(Value In Array((Event Player).uppercut_pvar, 4), And(Is Alive(Current Array Element), Compare(Angle Between Vectors(World Vector Of(Forward, Event Player, Rotation), Direction Towards(Event Player, Current Array Element)), <=, 90))));
        Set Player Variable At Index(Value In Array((Event Player).uppercut_pvar, 4), uppercut_pvar, 0, True);
        Set Player Variable At Index(Value In Array((Event Player).uppercut_pvar, 4), uppercut_pvar, 5, Event Player);
        Wait(0.016, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[doomfist/uppercut.opy]: Damage uppercut victims + vfx + uppercut knockback physics") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Event Player).uppercut_pvar) != False;
        Value In Array((Event Player).uppercut_pvar, 6) != Value In Array((Event Player).uppercut_pvar, 5);
    }
    actions {
        "damage"
        Damage(Event Player, Value In Array((Event Player).uppercut_pvar, 5), 50);
        Set Environment Credit Player(Event Player, Value In Array((Event Player).uppercut_pvar, 5));
        "upercut hit vfx"
        Play Effect(All Players(All Teams), Bad Explosion, Color(White), Event Player, 1);
        "knockback\nLose movement control"
        Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
        Apply Impulse(Event Player, Up, 13.5, To Player, Cancel Contrary Motion XYZ);
        Apply Impulse(Event Player, World Vector Of(Forward, Value In Array((Event Player).uppercut_pvar, 5), Rotation), 8.5, To World, Cancel Contrary Motion XYZ);
        Wait(3, Ignore Condition);
        "Regain movement control"
        Stop Forcing Throttle(Event Player);
    }
}

rule ("[doomfist/uppercut.opy]: Best defense for each uppercut victim hit") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Event Player).uppercut_pvar) != False;
        Value In Array((Event Player).uppercut_pvar, 6) != Value In Array((Event Player).uppercut_pvar, 5);
    }
    actions {
        "best defense"
        Stop Chasing Player Variable(Value In Array((Event Player).uppercut_pvar, 5), uppercut_shields);
        Modify Player Variable(Value In Array((Event Player).uppercut_pvar, 5), uppercut_shields, Add, 30);
        Wait(1, Ignore Condition);
        Chase Player Variable At Rate(Value In Array((Event Player).uppercut_pvar, 5), uppercut_shields, 0, 3, None);
    }
}

rule ("[doomfist/uppercut.opy]: Uppercut victim state variables") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Event Player).uppercut_pvar) != False;
        Value In Array((Event Player).uppercut_pvar, 6) != Value In Array((Event Player).uppercut_pvar, 5);
    }
    actions {
        Set Player Variable At Index(Event Player, uppercut_pvar, 6, Value In Array((Event Player).uppercut_pvar, 5));
        Wait Until(Not((Value In Array((Event Player).uppercut_pvar, 5)).is_using_uppercut), 999999999999999);
        Set Player Variable At Index(Event Player, uppercut_pvar, 0, False);
        Set Player Variable At Index(Event Player, uppercut_pvar, 5, Null);
        Set Player Variable At Index(Event Player, uppercut_pvar, 6, Null);
    }
}

rule ("[doomfist/uppercut.opy]: Heal doomfist uppercut shields") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Update Every Frame(Compare((Event Player).uppercut_shields, >, 0)) != False;
        Update Every Frame(Compare(Health(Event Player), <, Max Health(Event Player))) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, uppercut_pvar, 3, Health(Event Player));
        Heal(Event Player, Null, (Event Player).uppercut_shields);
        Modify Player Variable(Event Player, uppercut_shields, Subtract, Min(Subtract(Max Health(Event Player), Value In Array((Event Player).uppercut_pvar, 3)), (Event Player).uppercut_shields));
        Wait(0.016, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[doomfist/slam.opy]: Execute slam") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 1)) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
        Is Meleeing(Event Player) == False;
        Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)) == False;
        (Event Player).is_ultimate_locked == False;
        Value In Array((Event Player).uppercut_pvar, 1) == False;
        Is Communicating Any Emote(Event Player) == False;
    }
    actions {
        "clear slammed victims"
        Set Player Variable(Event Player, slam_victims, Empty Array);
        If(Compare((Event Player).slam_to_use, ==, 1));
            If(And(Compare(Distance Between((Event Player).indicator_slam_position, (Event Player).proto_indicator_slam_position), <, 5), Compare(Angle Between Vectors(Down, Facing Direction Of(Event Player)), <=, Add(90, Global.DOOMFIST_SLAM_PITCH_ANGLE))));
                "Initiate Indicator Slam"
                Stop Chasing Player Variable(Event Player, proto_indicator_slam_position);
                Stop Chasing Player Variable(Event Player, indicator_slam_position);
                Set Player Variable(Event Player, stop_slam, False);
                Set Player Variable(Event Player, proto_indicator_slam_position, Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(Global.DOOMFIST_SEISMIC_SLAM_RADIUS, Facing Direction Of(Event Player))), Null, All Players(All Teams), False));
                Set Player Variable(Event Player, indicator_slam_position, If-Then-Else(Compare(Distance Between(Eye Position(Event Player), (Event Player).proto_indicator_slam_position), >=, Global.DOOMFIST_SEISMIC_SLAM_RADIUS), Ray Cast Hit Position((Event Player).proto_indicator_slam_position, Add((Event Player).proto_indicator_slam_position, Multiply(5, Down)), Null, All Players(All Teams), False), (Event Player).proto_indicator_slam_position));
                Set Gravity(Event Player, 0);
                Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
                Call Subroutine(startSlamAnimation);
                While(And(And(And(Compare(Distance Between(Position Of(Event Player), (Event Player).indicator_slam_position), >, 2), Is Using Ability 1(Event Player)), Compare(Speed Of(Event Player), >, 2)), Not((Event Player).stop_slam)));
                    Set Player Variable(Event Player, slam_velocity_correction, Subtract(Multiply(25, Direction Towards(Position Of(Event Player), (Event Player).indicator_slam_position)), Velocity Of(Event Player)));
                    Apply Impulse(Event Player, (Event Player).slam_velocity_correction, Magnitude Of((Event Player).slam_velocity_correction), To World, Incorporate Contrary Motion);
                    Wait(0.016, Ignore Condition);
                End;
                Set Gravity(Event Player, 100);
                Wait Until(Or(Is On Ground(Event Player), Not(Is Using Ability 1(Event Player))), 999999999999999);
                Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
                Stop Forcing Throttle(Event Player);
            End;
        Else;
            "Initiate Ground Slam"
            Set Gravity(Event Player, 0);
            Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
            Call Subroutine(startSlamAnimation);
            "apply custom momentum"
            Apply Impulse(Event Player, Add(World Vector Of(Forward, Event Player, Rotation), Multiply(0.075, Up)), 16, To World, Incorporate Contrary Motion);
            Wait(0.3, Ignore Condition);
            Set Gravity(Event Player, 100);
            Wait Until(Or(Is On Ground(Event Player), Not(Is Using Ability 1(Event Player))), 999999999999999);
            Stop Forcing Throttle(Event Player);
    }
}

rule ("[doomfist/slam.opy]: Check for LOS during indicator") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Distance Between(Position Of(Event Player), (Event Player).indicator_slam_position) > 2;
        Is Using Ability 1(Event Player) == True;
        Speed Of(Event Player) > 2;
        (Event Player).stop_slam == False;
        Is In Line of Sight(Eye Position(Event Player), (Event Player).indicator_slam_position, Barriers Do Not Block LOS) == False;
    }
    actions {
        Wait(0.5, Abort When False);
        Set Player Variable(Event Player, stop_slam, True);
    }
}

rule ("[doomfist/slam.opy]: startSlamAnimation()") {
    event {
        Subroutine;
        startSlamAnimation;
    }
    actions {
        "Start slam animation"
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
        Allow Button(Event Player, Button(Ability 1));
        Press Button(Event Player, Button(Ability 1));
        Disallow Button(Event Player, Button(Ability 1));
        Wait(0.016, Ignore Condition);
        Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
    }
}

rule ("[doomfist/slam.opy]: Detect ground slam") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Altitude Of(Event Player) < 1;
    }
    actions {
        Set Player Variable(Event Player, slam_to_use, 0);
    }
}

rule ("[doomfist/slam.opy]: Detect indicator slam") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Altitude Of(Event Player) >= 3;
    }
    actions {
        Set Player Variable(Event Player, slam_to_use, 1);
    }
}

rule ("[doomfist/slam.opy]: Start tracking indicator slam destination") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).slam_to_use == 1;
        Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions {
        Chase Player Variable At Rate(Event Player, proto_indicator_slam_position, Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(Global.DOOMFIST_SEISMIC_SLAM_RADIUS, Facing Direction Of(Event Player))), Null, All Players(All Teams), False), 999999999999999, Destination and Rate);
        Chase Player Variable At Rate(Event Player, indicator_slam_position, If-Then-Else(Compare(Distance Between(Eye Position(Event Player), (Event Player).proto_indicator_slam_position), >=, Global.DOOMFIST_SEISMIC_SLAM_RADIUS), Ray Cast Hit Position((Event Player).proto_indicator_slam_position, Add((Event Player).proto_indicator_slam_position, Multiply(5, Down)), Null, All Players(All Teams), False), (Event Player).proto_indicator_slam_position), 999999999999999, Destination and Rate);
    }
}

rule ("[doomfist/slam.opy]: Stop tracking indicator slam destination") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        And(And(Compare((Event Player).slam_to_use, ==, 1), Compare(Ability Cooldown(Event Player, Button(Ability 1)), <=, 0)), Not(Is Using Ability 1(Event Player))) == False;
    }
    actions {
        Stop Chasing Player Variable(Event Player, proto_indicator_slam_position);
        Stop Chasing Player Variable(Event Player, indicator_slam_position);
    }
}

rule ("[doomfist/uppercut.opy]: Disable abilities when slamming") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        "Doomfist cannot melee during uppercut"
        Set Melee Enabled(Event Player, False);
        "Doomfist cannot shoot during slam"
        Set Primary Fire Enabled(Event Player, False);
        "Doomfist cannot punch during slam"
        Set Secondary Fire Enabled(Event Player, False);
        "Doomfist cannot uppercut during slam"
        Set Ability 2 Enabled(Event Player, False);
        Wait Until(Or(Is On Ground(Event Player), Not(Is Using Ability 1(Event Player))), 999999999999999);
        Set Melee Enabled(Event Player, True);
        Set Primary Fire Enabled(Event Player, True);
        Set Secondary Fire Enabled(Event Player, True);
        Set Ability 2 Enabled(Event Player, True);
    }
}

rule ("[doomfist/slam.opy]: Calculate slam damage based on air time") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, slam_damage, 0);
        Wait Until(Not(Is On Ground(Event Player)), 999999999999999);
        "Makes ground slam damage 49"
        If(Compare((Event Player).slam_to_use, ==, 0));
            Wait(0.016, Ignore Condition);
        End;
        Chase Player Variable At Rate(Event Player, slam_damage, Global.DOOMFIST_SLAM_DAMAGE_MAX, 100, None);
        Wait Until(Or(Is On Ground(Event Player), Not(Is Using Ability 1(Event Player))), 999999999999999);
        Stop Chasing Player Variable(Event Player, slam_damage);
        Wait(1, Restart When True);
    }
}

rule ("[doomfist/slam.opy]: Remove OW2 slam damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        "Ability used to damage player is Seismic Slam"
        Event Ability == Button(Ability 1);
    }
    actions {
        Heal(Victim, Null, Event Damage);
    }
}

rule ("[doomfist/slam.opy]: Find slammed victims") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        "Ability used to damage player is Seismic Slam"
        Event Ability == Button(Ability 1);
    }
    actions {
        "[TODO]: add condition to check victim in 60 degree cone"
        If(And(Compare(1, <=, Distance Between(Attacker, Victim)), Compare(Distance Between(Attacker, Victim), <=, 8)));
            Modify Player Variable(Attacker, slam_victims, Append To Array, Victim);
            Damage(Attacker, Null, 5);
        "Handle OW2 slam victims"
        Else;
            "Transfer shield gained from uppercut to shield gained from OW2 slam victims"
            Damage(Attacker, Null, Subtract(35, Min(35, (Attacker).uppercut_shields)));
            Modify Player Variable(Attacker, uppercut_shields, Subtract, Min(35, (Attacker).uppercut_shields));
    }
}

rule ("[doomfist/slam.opy]: Slammed victims damage + bounce effect") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        "Ability used to damage player is Seismic Slam"
        Event Ability == Button(Ability 1);
        Array Contains((Attacker).slam_victims, Victim) == True;
    }
    actions {
        "Custom slam damage"
        Damage(Victim, Attacker, Round To Integer((Attacker).slam_damage, Down));
        Set Gravity(Victim, 50);
        "Boop slammed victims up"
        Apply Impulse(Victim, Up, 5.25, To World, Cancel Contrary Motion XYZ);
        "Push/Pull slammed victims; multiply pull magnitude by 1.5 to counteract air resistance"
        Apply Impulse(Victim, Direction Towards(Victim, Attacker), Multiply(1.5, Subtract(Distance Between(Victim, Attacker), 4)), To World, Cancel Contrary Motion XYZ);
        Set Gravity(Victim, 100);
    }
}

rule ("[doomfist/slam.opy]: createSlamIndicatorGui()") {
    event {
        Subroutine;
        createSlamIndicatorGui;
    }
    actions {
        For Global Variable(slam_i, 0, 0, 1);
            If(Compare(Value In Array((Event Player).slam_indicator_beam_id, Global.slam_i), ==, Null));
                Create Beam Effect(If-Then-Else(And(And(And(And(And(And(Compare(Distance Between((Event Player).indicator_slam_position, (Event Player).proto_indicator_slam_position), <, 5), Compare(Angle Between Vectors(Down, Facing Direction Of(Event Player)), <=, Add(90, Global.DOOMFIST_SLAM_PITCH_ANGLE))), Compare((Event Player).slam_to_use, ==, 1)), Compare(Ability Cooldown(Event Player, Button(Ability 1)), <=, 0)), Not(Is Firing Secondary(Event Player))), Not(Is Using Ability 1(Event Player))), Not(Is Using Ultimate(Event Player))), Event Player, Null), Good Beam, Update Every Frame(Add((Event Player).indicator_slam_position, World Vector Of(Add(Multiply(Cosine From Degrees(Subtract(30, Divide(Multiply(Evaluate Once(Global.slam_i), 60), -1))), Forward), Multiply(Sine From Degrees(Subtract(30, Divide(Multiply(Evaluate Once(Global.slam_i), 60), -1))), Left)), Event Player, Rotation))), Update Every Frame(Add((Event Player).indicator_slam_position, Multiply(8, World Vector Of(Add(Multiply(Cosine From Degrees(Subtract(30, Divide(Multiply(Evaluate Once(Global.slam_i), 60), -1))), Forward), Multiply(Sine From Degrees(Subtract(30, Divide(Multiply(Evaluate Once(Global.slam_i), 60), -1))), Left)), Event Player, Rotation)))), Color(Blue), Visible To Position and Radius);
                Set Player Variable At Index(Event Player, slam_indicator_beam_id, Global.slam_i, Last Created Entity);
            End;
        End;
        For Global Variable(slam_i, 0, 6, 1);
            If(Compare(Value In Array((Event Player).slam_indicator_ring_id, Global.slam_i), ==, Null));
                Create Effect(If-Then-Else(And(And(And(And(And(And(Compare(Distance Between((Event Player).indicator_slam_position, (Event Player).proto_indicator_slam_position), <, 5), Compare(Angle Between Vectors(Down, Facing Direction Of(Event Player)), <=, Add(90, Global.DOOMFIST_SLAM_PITCH_ANGLE))), Compare((Event Player).slam_to_use, ==, 1)), Compare(Ability Cooldown(Event Player, Button(Ability 1)), <=, 0)), Not(Is Firing Secondary(Event Player))), Not(Is Using Ability 1(Event Player))), Not(Is Using Ultimate(Event Player))), Event Player, Null), Ring, Color(Blue), Update Every Frame(Add((Event Player).indicator_slam_position, Multiply(Divide(Multiply(Evaluate Once(Add(Global.slam_i, 1)), 8), 6), World Vector Of(Forward, Event Player, Rotation)))), Multiply(Divide(Multiply(Evaluate Once(Add(Global.slam_i, 1)), 8), 6), 0.499999999999999), Visible To Position and Radius);
                Set Player Variable At Index(Event Player, slam_indicator_ring_id, Global.slam_i, Last Created Entity);
            End;
        End;
    }
}

rule ("[doomfist/slam.opy]: destroySlamIndicatorGui()") {
    event {
        Subroutine;
        destroySlamIndicatorGui;
    }
    actions {
        For Global Variable(slam_i, 0, Count Of((Event Player).slam_indicator_beam_id), 1);
            Destroy Effect(Value In Array((Event Player).slam_indicator_beam_id, Global.slam_i));
            Set Player Variable At Index(Event Player, slam_indicator_beam_id, Global.slam_i, Null);
        End;
        For Global Variable(slam_i, 0, Count Of((Event Player).slam_indicator_ring_id), 1);
            Destroy Effect(Value In Array((Event Player).slam_indicator_ring_id, Global.slam_i));
            Set Player Variable At Index(Event Player, slam_indicator_ring_id, Global.slam_i, Null);
        End;
    }
}

rule ("[doomfist/punch.opy]: Initialize rocket punch") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
    }
    actions {
        Set Player Variable(Event Player, punched_victims, Empty Array);
        Set Player Variable(Event Player, wall_impacted_victims, Empty Array);
        Set Player Variable(Event Player, punch_charge_time, 0);
        Chase Player Variable At Rate(Event Player, punch_charge_time, 1.4, 1, None);
        Wait Until(Not(Is Button Held(Event Player, Button(Secondary Fire))), 999999999999999);
        Stop Chasing Player Variable(Event Player, punch_charge_time);
        Set Player Variable(Event Player, punch_charge_time, Max(0.192, (Event Player).punch_charge_time));
        "cooldown"
        Wait Until(Not(Is Firing Secondary(Event Player)), 999999999999999);
        "workshop bug (doesn't work)"
        Set Ability Cooldown(Event Player, Button(Secondary Fire), Global.DOOMFIST_PUNCH_COOLDOWN);
    }
}

rule ("[doomfist/punch.opy]: Find wall impacted victims") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Array Contains((Attacker).punched_victims, Victim) == True;
        Array Contains((Attacker).wall_impacted_victims, Victim) == False;
    }
    actions {
        Modify Player Variable(Attacker, wall_impacted_victims, Append To Array, Victim);
        "OW1 single punch victim"
        If(Compare(Count Of((Attacker).wall_impacted_victims), ==, 1));
            Damage(Victim, Attacker, Subtract(Add(Multiply(82.78145695364239, Subtract((Event Player).punch_charge_time, 0.192)), 50), Event Damage));
        "OW2 multi punch victim"
        Else;
            Heal(Victim, Null, Event Damage);
    }
}

rule ("[doomfist/punch.opy]: Find punched victims") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Array Contains((Attacker).punched_victims, Victim) == False;
    }
    actions {
        Modify Player Variable(Attacker, punched_victims, Append To Array, Victim);
        "OW1 single punch victim"
        If(Compare(Count Of((Attacker).punched_victims), ==, 1));
            Damage(Victim, Attacker, Subtract(Add(Multiply(41.390728476821195, Subtract((Event Player).punch_charge_time, 0.192)), 50), Event Damage));
            "Apply knockback manually"
            Apply Impulse(Victim, Facing Direction Of(Attacker), Add(Multiply(12.417218543046358, Subtract((Event Player).punch_charge_time, 0.192)), 15), To World, Cancel Contrary Motion);
            Damage(Attacker, Null, 5);
        "OW2 multi punch victim"
        Else;
            "Heal back OW2 punch victims"
            Heal(Victim, Null, Event Damage);
            "Transfer shield gained from uppercut to shield gained from OW2 punch victims"
            Damage(Attacker, Null, Subtract(35, Min(35, (Attacker).uppercut_shields)));
            Modify Player Variable(Attacker, uppercut_shields, Subtract, Min(35, (Attacker).uppercut_shields));
    }
}

rule ("[doomfist/punch.opy]: Remove Empowered Punch from ultimate") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 2));
        Set Player Variable(Event Player, is_ultimate_locked, True);
        Wait Until(Is Button Held(Event Player, Button(Primary Fire)), 4.8);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Start Holding Button(Event Player, Button(Secondary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Set Status(Event Player, Null, Stunned, 0.016);
        Stop Holding Button(Event Player, Button(Secondary Fire));
        Set Secondary Fire Enabled(Event Player, False);
        Wait(0.016, Ignore Condition);
        Set Secondary Fire Enabled(Event Player, True);
        Set Player Variable(Event Player, is_ultimate_locked, False);
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
        If(Is Button Held(Event Player, Button(Ability 1)));
            "Without wait, doom gets extra slam damage"
            Wait(0.016, Ignore Condition);
            Press Button(Event Player, Button(Ability 1));
        End;
        Allow Button(Event Player, Button(Ability 2));
        If(Is Button Held(Event Player, Button(Ability 2)));
            Press Button(Event Player, Button(Ability 2));
        End;
        Allow Button(Event Player, Button(Secondary Fire));
    }
}

rule ("[doomfist/punch.opy]: Remove stun from wall impact") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Array Contains((Event Player).wall_impacted_victims, Victim) == True;
    }
    actions {
        Clear Status(Victim, Stunned);
    }
}

rule ("[doomfist/meteor.opy]: Deal OW1 Meteor Strike damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Ultimate);
        "Only activate this rule when damage is dealt by inner ring (/2 accounts for damage reduction from armor, nanoboost, etc)"
        Event Damage < 200;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Add(200, Multiply(3.7, Subtract(Event Damage, 100))), Event Damage));
    }
}

rule ("[doomfist/meteor.opy]: Compensate Meteor Strike slow effect") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Ultimate);
    }
    actions {
        Set Move Speed(Victim, 200);
        Set Player Variable(Victim, meteor_strike_slow_time, 3);
        Chase Player Variable At Rate(Victim, meteor_strike_slow_time, 0, 1, None);
    }
}

rule ("[doomfist/meteor.opy]: Reset Meteor Strike slow effect compensation") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).meteor_strike_slow_time <= 0;
    }
    actions {
        Stop Chasing Player Variable(Event Player, meteor_strike_slow_time);
        Set Move Speed(Event Player, 100);
    }
}

rule ("[doomfist/meteor.opy]: OW1 Meteor Strike knockback") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Ultimate);
    }
    actions {
        Set Gravity(Victim, 50);
        "Boop slammed victims up"
        Apply Impulse(Victim, Up, 5, To World, Cancel Contrary Motion XYZ);
        "Push/Pull slammed victims; multiply pull magnitude by 1.5 to counteract air resistance"
        Apply Impulse(Victim, Direction Towards(Attacker, Victim), Divide(20, Max(Distance Between(Attacker, Victim), 2)), To World, Cancel Contrary Motion XYZ);
        Set Gravity(Victim, 100);
    }
}

rule ("[doomfist/meteor.opy]: Remove Meteor Strike healing") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Healing Dealt(Event Player, 0);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Set Healing Dealt(Event Player, 100);
    }
}

rule ("[doomfist/cannon.opy]: Deal launch hand cannon damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        "Deal additional damage to match OW1 damage"
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.454545454545454), Event Damage));
    }
}

rule ("[doomfist/init.opy]: Initialize Doomfist") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 250);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1600);
        Set Knockback Received(Event Player, 200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable(Event Player, punched_victims, Empty Array);
        Set Player Variable(Event Player, wall_impacted_victims, Empty Array);
        Disallow Button(Event Player, Button(Ability 1));
        Set Player Variable(Event Player, slam_damage, 0);
        Call Subroutine(createSlamIndicatorGui);
        Set Player Variable(Event Player, uppercut_shields, 0);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[doomfist/init.opy]: Clean up Doomfist") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Doomfist);
    }
    actions {
        Wait Until(Compare(Hero Of(Event Player), !=, Hero(Doomfist)), 999999999999999);
        Call Subroutine(destroySlamIndicatorGui);
    }
}

rule ("[dva/hp.opy]: Correct DVa mech health") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is In Alternate Form(Event Player) == False;
        First Of((Event Player).reset_pvar) == False;
    }
    actions {
        "wait(1, Wait.ABORT_WHEN_FALSE)"
        Set Player Variable(Event Player, remech_damage_taken, Subtract(Max Health(Event Player), Health(Event Player)));
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 300);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 300);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Health(Event Player, Subtract(Max Health(Event Player), (Event Player).remech_damage_taken));
    }
}

rule ("[dva/hp.opy]: Correct DVa pilot health") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is In Alternate Form(Event Player) == True;
        Max Health Of Type(Event Player, Health) != 150;
        First Of((Event Player).reset_pvar) == False;
    }
    actions {
        Call Subroutine(clearCustomHp);
    }
}

rule ("[dva/gun.opy]: OW1 DVa movement penalty when shooting") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is In Alternate Form(Event Player) == False;
        Is Button Held(Event Player, Button(Primary Fire)) == True;
        Is Using Ability 1(Event Player) == False;
    }
    actions {
        Set Move Speed(Event Player, 71.42857142857143);
    }
}

rule ("[dva/gun.opy]: Remove movement penalty when not shooting") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Button Held(Event Player, Button(Primary Fire)) == False;
    }
    actions {
        Set Move Speed(Event Player, 100);
    }
}

rule ("[dva/gun.opy]: Remove movement penalty when flying") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Move Speed(Event Player, 100);
    }
}

rule ("[dva/booster.opy]: Decouple melee button from activating melee animation during booster") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Melee));
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Allow Button(Event Player, Button(Melee));
    }
}

rule ("[dva/booster.opy]: Cancel booster if melee pressed") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Is Button Held(Event Player, Button(Melee)) == True;
    }
    actions {
        Press Button(Event Player, Button(Ability 1));
        Allow Button(Event Player, Button(Melee));
        Press Button(Event Player, Button(Melee));
        Disallow Button(Event Player, Button(Melee));
    }
}

rule ("[dva/booster.opy]: Reduce boosters damage") {
    event {
        Player Dealt Damage;
        All;
        D.Va;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Heal(Victim, Null, -5);
    }
}

rule ("[dva/bomb.opy]: Force reset ult charge when DVa pops out of Mech") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is In Alternate Form(Event Player) == True;
    }
    actions {
        Abort If(Is Using Ultimate(Event Player));
        Set Ultimate Charge(Event Player, 0);
    }
}

rule ("[dva/matrix.opy]: set defense matrix cooldown") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Secondary Fire)) > 0;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 10);
    }
}

rule ("[dva/init.opy]: Initialize DVa") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Ability 2 Enabled(Event Player, False);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1989);
        Set Knockback Received(Event Player, 200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[echo/focusing_beam.opy]: Deal OW1 echo focusing beam under 50% hp") {
    event {
        Player Dealt Damage;
        All;
        Echo;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
        Multiply(100, Divide(Health(Victim), Max Health(Victim))) < 50;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.142857142857142), Event Damage));
    }
}

rule ("[echo/duplicate.opy]: Table of all heroes with custom hp") {
    event {
        Ongoing - Global;
    }
    actions {
        "tanks"
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(D.Va)), Array(300, 300, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Wrecking Ball)), Array(450, 100, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Junker Queen)), Array(400, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Mauga)), Array(600, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Orisa)), Array(200, 200, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Ramattra)), Array(250, 0, 100));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Reinhardt)), Array(300, 200, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Roadhog)), Array(600, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Sigma)), Array(250, 0, 200));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Winston)), Array(400, 100, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Zarya)), Array(200, 0, 200));
        "damage"
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Ashe)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Bastion)), Array(200, 100, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Cassidy)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Doomfist)), Array(250, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Genji)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Hanzo)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Junkrat)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Mei)), Array(250, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Pharah)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Reaper)), Array(250, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Soldier: 76)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Sojourn)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Sombra)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Symmetra)), Array(100, 0, 125));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Torbjörn)), Array(200, 50, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Tracer)), Array(150, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Venture)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Widowmaker)), Array(200, 0, 0));
        "supports"
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Ana)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Baptiste)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Brigitte)), Array(200, 50, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Illari)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Kiriko)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Lifeweaver)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Lúcio)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Mercy)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Moira)), Array(200, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Zenyatta)), Array(50, 0, 100));
    }
}

rule ("[echo/duplicate.opy]: Set Life for echo when duplicating a tank") {
    event {
        Ongoing - Each Player;
        All;
        Echo;
    }
    conditions {
        Is Duplicating(Event Player) == True;
    }
    actions {
        Call Subroutine(clearCustomHp);
        Set Player Variable(Event Player, hero_id_duplicated, Index Of Array Value(All Heroes, Hero Being Duplicated(Event Player)));
        Wait(1, Ignore Condition);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, First Of(Value In Array(Global.health_pool, (Event Player).hero_id_duplicated)));
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, Value In Array(Value In Array(Global.health_pool, (Event Player).hero_id_duplicated), 1));
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, Value In Array(Value In Array(Global.health_pool, (Event Player).hero_id_duplicated), 2));
        Call Subroutine(applyCustomHp);
    }
}

rule ("[echo/duplicate.opy]: Reinitialize echo after exiting duplicate") {
    event {
        Ongoing - Each Player;
        All;
        Echo;
    }
    conditions {
        Is Duplicating(Event Player) == False;
    }
    actions {
        Call Subroutine(clearCustomHp);
        Call Subroutine(resetStats);
        Call Subroutine(resetStatuses);
        Call Subroutine(resetFrenemies);
        Call Subroutine(resetUltCharge);
        Call Subroutine(resetSelfHealing);
        Call Subroutine(enableAllAbilities);
        Set Player Variable At Index(Event Player, reset_pvar, 0, True);
    }
}

rule ("[echo/duplicate.opy]: Correct duplicate ultimate charge rate") {
    event {
        Ongoing - Each Player;
        All;
        Echo;
    }
    conditions {
        Is Duplicating(Event Player) == True;
        Ultimate Charge Percent(Event Player) == 0;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Ultimate Charge(Event Player, Absolute Value(4.615384615384615));
    }
}

rule ("[echo/init.opy]: Initialize Echo") {
    event {
        Ongoing - Each Player;
        All;
        Echo;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
        Is Duplicating(Event Player) == False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2000);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[genji/init.opy]: Initialize Genji") {
    event {
        Ongoing - Each Player;
        All;
        Genji;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2400);
        Set Ammo(Event Player, 0, 24);
        Set Max Ammo(Event Player, 0, 24);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[genji/init.opy]: Deal OW1 shuriken damage") {
    event {
        Player Dealt Damage;
        All;
        Genji;
    }
    conditions {
        Array Contains(Array(Button(Primary Fire), Button(Secondary Fire)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.111111111111111), Event Damage));
    }
}

rule ("[hanzo/scatter.opy]:  fireScatterArrow()") {
    event {
        Subroutine;
        fireScatterArrow;
    }
    actions {
        Wait Until(Compare(Ray Cast Hit Position(Add(Add(Value In Array((Event Player).scatter_pvar, 2), Multiply(Value In Array((Event Player).scatter_pvar, 1), Subtract(Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)), 0.032))), Multiply(Multiply(Multiply(4.91, Down), Subtract(Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)), 0.032)), Subtract(Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)), 0.032))), Add(Add(Value In Array((Event Player).scatter_pvar, 2), Multiply(Value In Array((Event Player).scatter_pvar, 1), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)))), Multiply(Multiply(Multiply(4.91, Down), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar))), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)))), All Players(Opposite Team Of(Team Of(Event Player))), All Players(Team Of(Event Player)), True), !=, Add(Add(Value In Array((Event Player).scatter_pvar, 2), Multiply(Value In Array((Event Player).scatter_pvar, 1), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)))), Multiply(Multiply(Multiply(4.91, Down), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar))), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar))))), 100);
        Set Player Variable(Event Player, extend_player_collection, Ray Cast Hit Position(Add(Add(Value In Array((Event Player).scatter_pvar, 2), Multiply(Value In Array((Event Player).scatter_pvar, 1), Subtract(Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)), 0.032))), Multiply(Multiply(Multiply(4.91, Down), Subtract(Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)), 0.032)), Subtract(Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)), 0.032))), Add(Add(Value In Array((Event Player).scatter_pvar, 2), Multiply(Value In Array((Event Player).scatter_pvar, 1), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)))), Multiply(Multiply(Multiply(4.91, Down), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar))), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)))), All Players(Opposite Team Of(Team Of(Event Player))), All Players(Team Of(Event Player)), True));
        Set Player Variable(Event Player, extend_player_collection, Ray Cast Hit Normal(Add(Add(Value In Array((Event Player).scatter_pvar, 2), Multiply(Value In Array((Event Player).scatter_pvar, 1), Subtract(Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)), 0.032))), Multiply(Multiply(Multiply(4.91, Down), Subtract(Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)), 0.032)), Subtract(Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)), 0.032))), Add(Add(Value In Array((Event Player).scatter_pvar, 2), Multiply(Value In Array((Event Player).scatter_pvar, 1), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)))), Multiply(Multiply(Multiply(4.91, Down), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar))), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)))), All Players(Opposite Team Of(Team Of(Event Player))), All Players(Team Of(Event Player)), True));
        Set Player Variable(Event Player, extend_player_collection, Subtract(Add(Value In Array((Event Player).scatter_pvar, 1), Multiply(Multiply(9.82, Down), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)))), Multiply(Multiply(2, Dot Product(Add(Value In Array((Event Player).scatter_pvar, 1), Multiply(Multiply(9.82, Down), Subtract(Total Time Elapsed, First Of((Event Player).scatter_pvar)))), Normalize((Event Player).extend_player_collection))), Normalize((Event Player).extend_player_collection))));
        Play Effect(All Players(All Teams), Bad Explosion, If-Then-Else(Compare(Team Of(Event Player), ==, Team 1), Color(Team 1), Color(Team 2)), (Event Player).extend_player_collection, 0.7);
        Play Effect(All Players(All Teams), Explosion Sound, Color(White), (Event Player).extend_player_collection, 70);
        Set Player Variable(Event Player, extend_player_collection, 0);
        While(Compare((Event Player).extend_player_collection, <, 5));
            Create Projectile(Orb Projectile, Event Player, (Event Player).extend_player_collection, Direction From Angles(Subtract(Horizontal Angle From Direction((Event Player).extend_player_collection), Multiply(4, Cosine From Degrees(Add(90, Multiply((Event Player).extend_player_collection, 72))))), Subtract(Vertical Angle From Direction((Event Player).extend_player_collection), Multiply(4, Sine From Degrees(Add(90, Multiply((Event Player).extend_player_collection, 72)))))), To World, Damage, Opposite Team Of(Team Of(Event Player)), 75, 15, 0, Bad Explosion, Explosion Sound, 0, 110, 3, 0, 75, 9.82);
            Modify Player Variable(Event Player, extend_player_collection, Add, 1);
        End;
    }
}

rule ("[hanzo/scatter.opy]: fire scatter arrow") {
    event {
        Ongoing - Each Player;
        All;
        Hanzo;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)) == False;
        Is Button Held(Event Player, Button(Ability 2)) == True;
    }
    actions {
        Wait Until(Is Using Ability 2(Event Player), 0.3);
        If(Is Button Held(Event Player, Button(Primary Fire)));
            Start Rule(fireScatterArrow, Do Nothing);
            Disallow Button(Event Player, Button(Primary Fire));
            Press Button(Event Player, Button(Primary Fire));
            While(Is Using Ability 2(Event Player));
                Press Button(Event Player, Button(Ability 2));
                Wait(0.016, Ignore Condition);
            End;
            Set Ability Cooldown(Event Player, Button(Ability 2), 10);
        Else;
            Wait Until(Or(Is Firing Primary(Event Player), Not(Is Using Ability 2(Event Player))), 5);
            If(Is Firing Primary(Event Player));
                Start Rule(fireScatterArrow, Do Nothing);
                Disallow Button(Event Player, Button(Primary Fire));
                Press Button(Event Player, Button(Primary Fire));
                While(Is Using Ability 2(Event Player));
                    Press Button(Event Player, Button(Ability 2));
                    Wait(0.016, Ignore Condition);
                End;
                Set Ability Cooldown(Event Player, Button(Ability 2), 10);
            Else;
                Set Ability Cooldown(Event Player, Button(Ability 2), 0.2);
            End;
        End;
        Allow Button(Event Player, Button(Primary Fire));
    }
}

rule ("[hanzo/scatter.opy]: remove scatter arrow critical hit") {
    event {
        Player Dealt Damage;
        All;
        Hanzo;
    }
    conditions {
        Event Was Critical Hit == True;
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Heal(Victim, Null, Event Damage);
        Damage(Victim, Event Player, 75);
    }
}

rule ("[hanzo/scatter.opy]: Slow down hanzo when using scatter") {
    event {
        Ongoing - Each Player;
        All;
        Hanzo;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Multiply, 0.6);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999999999999);
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Divide, 0.6);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
    }
}

rule ("[hanzo/dragon.opy]: Set dragon speed") {
    event {
        Ongoing - Each Player;
        All;
        Hanzo;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        "arbitrarily decided based on trial and error"
        Set Projectile Speed(Event Player, 222.8);
        Wait Until(Is Using Ultimate(Event Player), 1);
        Set Projectile Speed(Event Player, 100);
    }
}

rule ("[hanzo/init.opy]: Initialize Hanzo") {
    event {
        Ongoing - Each Player;
        All;
        Hanzo;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1600);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[hanzo/init.opy]: Deal OW1 primary fire damage") {
    event {
        Player Dealt Damage;
        All;
        Hanzo;
    }
    conditions {
        Array Contains(Array(Button(Primary Fire), Button(Ability 1)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.083333333333333), Event Damage));
    }
}

rule ("[hammond/shields.opy]: OW1 Adaptive Shields") {
    event {
        Ongoing - Each Player;
        All;
        Wrecking Ball;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, hammond_shield_pvar, 0, Count Of(Players Within Radius(Eye Position(Event Player), 10, Opposite Team Of(Team Of(Event Player)), Surfaces And All Barriers)));
        Set Player Variable At Index(Event Player, hammond_shield_pvar, 1, Count Of(Players Within Radius(Eye Position(Event Player), 8, Opposite Team Of(Team Of(Event Player)), Surfaces And All Barriers)));
        Damage(Event Player, Null, Subtract(Add(Multiply(100, First Of((Event Player).hammond_shield_pvar)), 100), Add(Multiply(75, Value In Array((Event Player).hammond_shield_pvar, 1)), 100)));
    }
}

rule ("[hammond/shields.opy]: Disable OW2 shield transfer") {
    event {
        Ongoing - Each Player;
        All;
        Wrecking Ball;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 2));
        Wait(7, Ignore Condition);
        Allow Button(Event Player, Button(Ability 2));
    }
}

rule ("[hammond/grapple.opy]: Set Grappling Claw Cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Wrecking Ball;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Secondary Fire)) > 0;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 5);
    }
}

rule ("[hammond/init.opy]: Initialize Wrecking Ball") {
    event {
        Ongoing - Each Player;
        All;
        Wrecking Ball;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 450);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 100);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 100);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1700);
        Set Knockback Received(Event Player, 200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, True);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[illari/init.opy]: Initialize Illari") {
    event {
        Ongoing - Each Player;
        All;
        Illari;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 3000);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[junkerqueen/init.opy]: Initialize Junker Queen") {
    event {
        Ongoing - Each Player;
        All;
        Junker Queen;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 400);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 0.777777777777777);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2600);
        Start Healing Modification(Event Player, Event Player, 100, None);
        Set Player Variable(Event Player, jq_self_heal_id, Last Healing Modification ID);
        Set Knockback Received(Event Player, 200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, True);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[junkerqueen/init.opy]: Clean up Junker Queen") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Junker Queen);
    }
    actions {
        Wait Until(Compare(Hero Of(Event Player), !=, Hero(Junker Queen)), 999999999999999);
        Stop Healing Modification((Event Player).jq_self_heal_id);
    }
}

rule ("[junkerqueen/init.opy]: Compensate Junkerqueen global damage reduction") {
    event {
        Player Dealt Damage;
        All;
        Junker Queen;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Primary Fire), Button(Secondary Fire), Button(Ability 2)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[junkrat/mine.opy]: Only one mine") {
    event {
        Ongoing - Each Player;
        All;
        Junkrat;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 1));
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Set Ability Charge(Event Player, Button(Ability 1), 0);
        Wait(7, Ignore Condition);
        Set Ability Charge(Event Player, Button(Ability 1), 2);
        Allow Button(Event Player, Button(Ability 1));
    }
}

rule ("[junkrat/init.opy]: Initialize Junkrat") {
    event {
        Ongoing - Each Player;
        All;
        Junkrat;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Max Health(Event Player, 66.66666666666666);
        Add Health Pool To Player(Event Player, Health, 33.33333333333334, True, False);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 0.8);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[junkrat/init.opy]: Correct Mine, Tire damage") {
    event {
        Player Dealt Damage;
        All;
        Junkrat;
    }
    conditions {
        Array Contains(Array(Button(Ability 1), Button(Ultimate)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[kiriko/kunai.opy]: OW1 Kunai damage") {
    event {
        Player Dealt Damage;
        All;
        Kiriko;
    }
    conditions {
        "@Condition eventAbility == Button.SECONDARY_FIRE\nWorkshop bug: Kunai event Ability = null instead of secondary fire"
        Event Ability == Null;
        Event Damage >= Multiply(45, First Of((Event Player).stat_helper_pvar));
        Event Was Critical Hit == False;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), 1.111111111111111), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[kiriko/kunai.opy]: OW1 Kiriko fire rate") {
    event {
        Ongoing - Each Player;
        All;
        Kiriko;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Disallow Button(Event Player, Button(Secondary Fire));
        Wait(0.65, Ignore Condition);
        Allow Button(Event Player, Button(Secondary Fire));
        If(Is Button Held(Event Player, Button(Secondary Fire)));
            Press Button(Event Player, Button(Secondary Fire));
    }
}

rule ("[kiriko/suzu.opy]: Cleanse out hard stun effects") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Has Status(Event Player, Knocked Down) == True;
    }
    actions {
        Clear Status(Event Player, Knocked Down);
        Wait(0.8, Ignore Condition);
        If(Has Status(Event Player, Phased Out));
            Set Status(Event Player, Null, Phased Out, 0.65);
    }
}

rule ("[kiriko/suzu.opy]: Remove initial burst healing from suzu") {
    event {
        Ongoing - Each Player;
        All;
        Kiriko;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Healing Dealt(Event Player, 0);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999999999999);
        Set Healing Dealt(Event Player, 100);
    }
}

rule ("[kiriko/suzu.opy]: Allow self healing during suzu") {
    event {
        Ongoing - Each Player;
        All;
        Kiriko;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        If(Not(Array Contains(First Of((Event Player).self_heal_pvar), Button(Ability 2))));
            Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Append To Array, Button(Ability 2));
        End;
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
        Wait(0.65, Restart When True);
        Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Remove From Array By Value, Button(Ability 2));
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
    }
}

rule ("[kiriko/suzu.opy]: ow2 suzu hps") {
    event {
        Player Dealt Healing;
        All;
        Kiriko;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        "self healing"
        If(Compare(Healee, ==, Healer));
            Heal(Healee, Healer, Subtract(Multiply(Divide(Event Healing, Value In Array((Event Player).stat_helper_pvar, 1)), 1.090909090909090), Event Healing));
        "ally healing"
        Else;
            Heal(Healee, Healer, Subtract(Multiply(Divide(Event Healing, Value In Array((Event Player).stat_helper_pvar, 1)), 0.545454545454545), Event Healing));
    }
}

rule ("[kiriko/init.opy]: Initialize Kiriko") {
    event {
        Ongoing - Each Player;
        All;
        Kiriko;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2900);
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, True);
        Set Healing Dealt(Event Player, 192.30769230769232);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 1.333333333333333);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Max Ammo(Event Player, 0, 6);
        Set Ammo(Event Player, 0, 12);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[kiriko/init.opy]: Deal regular damage for any non custom damage") {
    event {
        Player Dealt Damage;
        All;
        Kiriko;
    }
    conditions {
        Array Contains(Array(Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[lifeweaver/init.opy]: Allow self healing during Rejuvanating Dash") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        Is On Ground(Event Player) == False;
        Is Button Held(Event Player, Button(Jump)) == False;
        Ability Cooldown(Event Player, Button(Jump)) <= 0;
    }
    actions {
        Wait Until(Or(Is Button Held(Event Player, Button(Jump)), Is On Ground(Event Player)), 999999999999999);
        Abort If(Is On Ground(Event Player));
        If(Not(Array Contains(First Of((Event Player).self_heal_pvar), Button(Jump))));
            Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Append To Array, Button(Jump));
        End;
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
        "waitUntil(eventPlayer.getAbilityCooldown(Button.JUMP) > 0, Math.INFINITY)"
        Wait(0.25, Ignore Condition);
        Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Remove From Array By Value, Button(Jump));
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
    }
}

rule ("[lifeweaver/init.opy]: Allow self healing during Tree of Life") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        If(Not(Array Contains(First Of((Event Player).self_heal_pvar), Button(Ultimate))));
            Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Append To Array, Button(Ultimate));
        End;
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Remove From Array By Value, Button(Ultimate));
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
    }
}

rule ("[lifeweaver/parting_gift.opy]: if parting gift collected remove.") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).parting_pvar, 1) == True;
    }
    actions {
        Destroy Effect(First Of((Event Player).parting_pvar));
        Set Player Variable At Index(Event Player, parting_pvar, 0, Null);
    }
}

rule ("[lifeweaver/parting_gift.opy]: spawn soul parting gift") {
    event {
        Player Died;
        All;
        Lifeweaver;
    }
    actions {
        Create Effect(Players On Hero(Hero(Lifeweaver), Opposite Team Of(Team Of(Event Player))), Orb, Color(Yellow), Add(Update Every Frame(Position Of(Event Player)), Vector(0, 1, 0)), 0.5, Visible To Position and Radius);
        Set Player Variable At Index(Event Player, parting_pvar, 0, Last Created Entity);
        Set Player Variable At Index(Event Player, parting_pvar, 1, False);
        Wait Until(Is Alive(Event Player), 999999999999999);
        Set Player Variable At Index(Event Player, parting_pvar, 1, True);
    }
}

rule ("[lifeweaver/parting_gift.opy]: collect parting gift") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        Number Of Dead Players(Opposite Team Of(Team Of(Event Player))) > 0;
        Distance Between(Position Of(Event Player), Position Of(First Of(Sorted Array(Filtered Array(All Dead Players(All Teams), Not(Value In Array((Current Array Element).parting_pvar, 1))), Current Array Element)))) < 1.5;
        Is True For Any(All Players(Opposite Team Of(Team Of(Event Player))), Compare(Value In Array((Current Array Element).parting_pvar, 1), !=, True)) == True;
        Normalized Health(Event Player) < 1;
    }
    actions {
        Set Player Variable At Index(First Of(Sorted Array(Is Dead(Event Player), Distance Between(Closest Player To(Position Of(Event Player), Team Of(Event Player)), Position Of(Current Array Element)))), parting_pvar, 1, True);
        Heal(Event Player, Null, 200);
        Wait(0.016, Abort When False);
        Loop If Condition Is True;
    }
}

rule ("[lifeweaver/parting_gift.opy]: parting gift collected") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).parting_pvar, 1) == True;
        Is Dead(Event Player) == True;
    }
    actions {
        Wait(0.016, Abort When False);
        Destroy Effect(First Of((Event Player).parting_pvar));
        Set Player Variable At Index(Event Player, parting_pvar, 0, Null);
        Stop Forcing Player Position(Event Player);
        Teleport(Event Player, Vector(0, -500, 0));
    }
}

rule ("[lifeweaver/parting_gift.opy]: follow players") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Dead(Event Player) == True;
        Value In Array((Event Player).parting_pvar, 1) != True;
        Number Of Heroes(Hero(Lifeweaver), Opposite Team Of(Team Of(Event Player))) > 0;
        Is True For Any(Players On Hero(Hero(Lifeweaver), Opposite Team Of(Team Of(Event Player))), And(And(Is Alive(Current Array Element), Compare(Distance Between(Position Of(Event Player), Position Of(Current Array Element)), <, 5)), Compare(Normalized Health(Current Array Element), <, 1))) == True;
    }
    actions {
        Wait(0.016, Abort When False);
        Set Player Variable(Event Player, parting_gift_position, Position Of(Event Player));
        Start Forcing Player Position(Event Player, (Event Player).parting_gift_position, True);
        Chase Player Variable At Rate(Event Player, parting_gift_position, Position Of(First Of(Sorted Array(Filtered Array(Players On Hero(Hero(Lifeweaver), Opposite Team Of(Team Of(Event Player))), And(Is Alive(Current Array Element), Compare(Normalized Health(Current Array Element), <, 1))), Distance Between(Position Of(Event Player), Position Of(Current Array Element))))), 8, Destination and Rate);
    }
}

rule ("[lifeweaver/parting_gift.opy]: stop following") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Or(Compare(Value In Array((Event Player).parting_pvar, 1), !=, True), Is Alive(Event Player)) == True;
        Or(Is True For Any(Players On Hero(Hero(Lifeweaver), Opposite Team Of(Team Of(Event Player))), And(And(Is Alive(Current Array Element), Compare(Distance Between(Position Of(Event Player), Position Of(Current Array Element)), <, 5)), Compare(Normalized Health(Current Array Element), <, 1))), Is Alive(Event Player)) == False;
    }
    actions {
        Stop Forcing Player Position(Event Player);
        Stop Chasing Player Variable(Event Player, parting_gift_position);
        If(And(Is Alive(Event Player), Not(Is In Spawn Room(Event Player))));
            Wait(0.1, Ignore Condition);
            If(Not(Has Status(Event Player, Burning)));
                Teleport(Event Player, Random Value In Array(Spawn Points(Team Of(Event Player))));
    }
}

rule ("[lifeweaver/init.opy]: Initialize Lifeweaver") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1600);
        "Still automatically self heals"
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, True);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[lucio/soundwave.opy]: OW1 Soundwave damage") {
    event {
        Player Dealt Damage;
        All;
        Lúcio;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Multiply(Event Damage, 0.857142857142857)));
    }
}

rule ("[lucio/soundwave.opy]: consume soundwave ammo") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Ammo(Event Player, 0, Max(0, Subtract(Ammo(Event Player, 0), 4)));
    }
}

rule ("[lucio/soundwave.opy]: disallow during reload") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Reloading(Event Player) == True;
    }
    actions {
        Set Secondary Fire Enabled(Event Player, False);
        Wait Until(Not(Is Reloading(Event Player)), 999999999999999);
        Set Secondary Fire Enabled(Event Player, True);
    }
}

rule ("[lucio/aura.opy]: lucioAura()") {
    event {
        Subroutine;
        lucioAura;
    }
    actions {
        Set Player Variable(Event Player, cross_fade_stats, Array(Custom String("Speed", Null, Null, Null), True, Custom String("Toggle", Null, Null, Null), Empty Array, Empty Array, Empty Array));
        If(Compare((Event Player).cross_fade_effects, ==, Null));
        End;
        Create Effect(If-Then-Else(Compare(Value In Array((Event Player).cross_fade_stats, 1), ==, True), All Players(All Teams), Empty Array), Ring, If-Then-Else(Compare(First Of((Event Player).cross_fade_stats), ==, Custom String("Speed", Null, Null, Null)), Color(Green), Color(Yellow)), Add(Ray Cast Hit Position(Add(Position Of(Event Player), Up), Subtract(Update Every Frame(Position Of(Event Player)), Vector(0, 99, 0)), Null, Event Player, False), Multiply(Up, 0.1)), 30, Visible To Position Radius and Color);
        Set Player Variable(Event Player, cross_fade_effects, Last Text ID);
    }
}

rule ("[lucio/aura.opy]: cleanUpAura()") {
    event {
        Subroutine;
        cleanUpAura;
    }
    actions {
        Destroy Effect((Event Player).cross_fade_effects);
        Destroy All Effects;
        Set Player Variable(Event Player, cross_fade_effects, Null);
    }
}

rule ("[lucio/aura.opy]: Launch wallride") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is On Wall(Event Player) == True;
    }
    actions {
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Multiply, 0.77);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
        Wait Until(Not(Is On Wall(Event Player)), 3);
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Divide, 0.77);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
        If(Is On Wall(Event Player));
            Press Button(Event Player, Button(Crouch));
            Wait(0.016, Ignore Condition);
            If(Is On Wall(Event Player));
                Press Button(Event Player, Button(Jump));
            End;
        Else;
            Apply Impulse(Event Player, Multiply(Velocity Of(Event Player), -1), 2.5, To World, Incorporate Contrary Motion);
    }
}

rule ("[lucio/aura.opy]: Cross Fade heal") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 1(Event Player) == False;
    }
    actions {
        Set Player Variable At Index(Event Player, cross_fade_stats, 0, Custom String("Healing", Null, Null, Null));
        Wait(0.38, Ignore Condition);
        Wait Until(Is Using Ability 1(Event Player), 999999999999999);
    }
}

rule ("[lucio/aura.opy]: Cross Fade speed") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, cross_fade_stats, 0, Custom String("Speed", Null, Null, Null));
        Wait(0.38, Ignore Condition);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Loop If Condition Is True;
    }
}

rule ("[lucio/aura.opy]: Cross Fade Targets") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).cross_fade_stats, 1) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, cross_fade_stats, 4, Players Within Radius(Event Player, 30, Team Of(Event Player), Surfaces And Enemy Barriers));
        Modify Player Variable At Index(Event Player, cross_fade_stats, 3, Append To Array, Filtered Array(Value In Array((Event Player).cross_fade_stats, 4), Not(Array Contains(Value In Array((Event Player).cross_fade_stats, 3), Current Array Element))));
        Set Player Variable At Index(Event Player, cross_fade_stats, 5, Empty Array);
        For Player Variable(Event Player, cross_fade_index, 0, Count Of(Value In Array((Event Player).cross_fade_stats, 3)), 1);
            If(Array Contains(Value In Array((Event Player).cross_fade_stats, 4), Value In Array(Value In Array((Event Player).cross_fade_stats, 3), (Event Player).cross_fade_index)));
                Modify Player Variable At Index(Event Player, cross_fade_stats, 5, Append To Array, 1);
            Else;
                Modify Player Variable At Index(Event Player, cross_fade_stats, 5, Append To Array, Subtract(Value In Array(Value In Array((Event Player).cross_fade_stats, 6), (Event Player).cross_fade_index), 0.1));
            End;
        End;
        Set Player Variable At Index(Event Player, cross_fade_stats, 6, Value In Array((Event Player).cross_fade_stats, 5));
        Modify Player Variable At Index(Event Player, cross_fade_stats, 3, Remove From Array By Value, Filtered Array(Value In Array((Event Player).cross_fade_stats, 3), Compare(Value In Array(Value In Array((Event Player).cross_fade_stats, 6), Current Array Index), <=, 0)));
        Modify Player Variable At Index(Event Player, cross_fade_stats, 6, Remove From Array By Value, Filtered Array(Value In Array((Event Player).cross_fade_stats, 6), Compare(Current Array Element, <=, 0)));
        Wait(0.016, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[lucio/aura.opy]: Cross Fade Speed") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is True For Any(All Players(Team Of(Event Player)), And(And(Array Contains(Value In Array((Current Array Element).cross_fade_stats, 3), Event Player), Compare(First Of((Current Array Element).cross_fade_stats), ==, Custom String("Speed", Null, Null, Null))), Compare(Value In Array((Current Array Element).cross_fade_stats, 1), ==, True))) == True;
    }
    actions {
        Set Move Speed(Event Player, 125);
        Wait Until(Is True For All(All Players(Team Of(Event Player)), Or(Or(Not(Array Contains(Value In Array((Current Array Element).cross_fade_stats, 3), Event Player)), Compare(First Of((Current Array Element).cross_fade_stats), !=, Custom String("Speed", Null, Null, Null))), Compare(Value In Array((Current Array Element).cross_fade_stats, 1), ==, False))), 999999999999999);
        Set Move Speed(Event Player, 100);
    }
}

rule ("[lucio/aura.opy]: Cross Fade Healing") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is True For Any(All Players(Team Of(Event Player)), And(And(Array Contains(Value In Array((Current Array Element).cross_fade_stats, 3), Event Player), Compare(First Of((Current Array Element).cross_fade_stats), ==, Custom String("Healing", Null, Null, Null))), Compare(Value In Array((Current Array Element).cross_fade_stats, 1), ==, True))) == True;
    }
    actions {
        While(Is True For Any(All Players(Team Of(Event Player)), And(And(Array Contains(Value In Array((Current Array Element).cross_fade_stats, 3), Event Player), Compare(First Of((Current Array Element).cross_fade_stats), ==, Custom String("Healing", Null, Null, Null))), Compare(Value In Array((Current Array Element).cross_fade_stats, 1), ==, True))));
            If(And(Compare(First Of(Filtered Array(All Players(Team Of(Event Player)), And(And(Array Contains(Value In Array((Current Array Element).cross_fade_stats, 3), Event Player), Compare(First Of((Current Array Element).cross_fade_stats), ==, Custom String("Healing", Null, Null, Null))), Compare(Value In Array((Current Array Element).cross_fade_stats, 1), ==, True)))), ==, Event Player), Compare(Count Of(Filtered Array(All Players(Team Of(Event Player)), And(And(Array Contains(Value In Array((Current Array Element).cross_fade_stats, 3), Event Player), Compare(First Of((Current Array Element).cross_fade_stats), ==, Custom String("Healing", Null, Null, Null))), Compare(Value In Array((Current Array Element).cross_fade_stats, 1), ==, True)))), ==, 1)));
                Heal(Event Player, Event Player, 1);
            Else;
                Heal(Event Player, Filtered Array(All Players(Team Of(Event Player)), And(And(Array Contains(Value In Array((Current Array Element).cross_fade_stats, 3), Event Player), Compare(First Of((Current Array Element).cross_fade_stats), ==, Custom String("Healing", Null, Null, Null))), Compare(Value In Array((Current Array Element).cross_fade_stats, 1), ==, True))), 1.6);
            End;
            Wait(0.1, Ignore Condition);
        End;
    }
}

rule ("[lucio/aura.opy]: set correct toggle") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is In Alternate Form(Event Player) == False;
    }
    actions {
        Set Player Variable At Index(Event Player, cross_fade_stats, 0, Custom String("Healing", Null, Null, Null));
    }
}

rule ("[lucio/sound_barrier.opy]: sound barrier reduce overhealth if on ground") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Health Of Type(Event Player, Health) > Add(First Of((Event Player).custom_hp_pvar), 500);
    }
    actions {
        Wait(0.016, Ignore Condition);
        Wait Until(Is On Ground(Event Player), 999999999999999);
        Damage(Players Within Radius(Position Of(Event Player), 30, Team Of(Event Player), Surfaces And Enemy Barriers), Null, 250);
    }
}

rule ("[lucio/init.opy]: Initialize Lucio") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 3000);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Call Subroutine(lucioAura);
        Set Knockback Dealt(Event Player, 133.92857142857142);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[lucio/init.opy]: OW1 Sonic Amplifier damage") {
    event {
        Player Dealt Damage;
        All;
        Lúcio;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.111111111111111), Event Damage));
    }
}

rule ("[lucio/init.opy]: Clean up Lucio") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Lúcio);
    }
    actions {
        Wait Until(Compare(Hero Of(Event Player), !=, Hero(Lúcio)), 999999999999999);
        Call Subroutine(cleanUpAura);
    }
}

rule ("[mauga/init.opy]: Initialize Mauga") {
    event {
        Ongoing - Each Player;
        All;
        Mauga;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 600);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2100);
        Set Knockback Received(Event Player, 200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, True);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[mei/blaster.opy]: 15 icicle ammo consumption.") {
    event {
        Ongoing - Each Player;
        All;
        Mei;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Firing Secondary(Event Player)), 999999999999999);
        Set Ammo(Event Player, 0, Max(0, Add(Ammo(Event Player, 0), 10)));
        Set Ammo(Event Player, 0, Max(0, Subtract(Ammo(Event Player, 0), 15)));
    }
}

rule ("[mei/blaster.opy]: Track freezing on enemy") {
    event {
        Player Dealt Damage;
        All;
        Mei;
    }
    conditions {
        Event Ability == Button(Primary Fire);
        (Victim).freeze_progress < 100;
    }
    actions {
        Stop Chasing Player Variable(Victim, freeze_slow_linger_time);
        "victims started taking freeze damage"
        If(Compare((Victim).freeze_progress, ==, 0));
            Set Player Variable(Victim, freeze_progress, 20);
        Else;
            Modify Player Variable(Victim, freeze_progress, Add, 2.85);
        End;
        Set Player Variable(Victim, freeze_move_penalty, If-Then-Else(Compare((Victim).freeze_progress, <, 70), (Victim).freeze_progress, 70));
        "victim.setMoveSpeed(100-victim.freeze_move_penalty)"
        Set Player Variable(Victim, freeze_slow_linger_time, 0);
        Chase Player Variable At Rate(Victim, freeze_slow_linger_time, 1, 1, None);
    }
}

rule ("[mei/blaster.opy]: Freeze enemy") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        (Victim).freeze_progress >= 100;
    }
    actions {
        "1x feels too short for some reason"
        Set Status(Victim, Event Player, Frozen, 1.5);
        Wait Until(Not(Has Status(Victim, Frozen)), 999999999999999);
        Call Subroutine(clearFreezeEffect);
    }
}

rule ("[mei/blaster.opy]: clear freeze after exceeding linger time") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).freeze_slow_linger_time >= 1;
    }
    actions {
        Call Subroutine(clearFreezeEffect);
    }
}

rule ("[mei/blaster.opy]: clearFreezeEffect()") {
    event {
        Subroutine;
        clearFreezeEffect;
    }
    actions {
        Stop Chasing Player Variable(Event Player, freeze_slow_linger_time);
        Set Move Speed(Event Player, 100);
        Set Player Variable(Event Player, freeze_progress, 0);
    }
}

rule ("[mei/blaster.opy]: OW1 blaster damage") {
    event {
        Player Dealt Damage;
        All;
        Mei;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Multiply(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), 0.55)));
    }
}

rule ("[mei/cryo_freeze.opy]: OW1 Cryo-Freeze healing") {
    event {
        Player Dealt Healing;
        All;
        Mei;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        If(Compare(Healee, ==, Healer));
            Heal(Healee, Healer, Subtract(Multiply(Divide(Event Healing, Value In Array((Event Player).stat_helper_pvar, 1)), 0.48), Event Healing));
    }
}

rule ("[mei/cryo_freeze.opy]: Allow self healing during Cryo-Freeze") {
    event {
        Ongoing - Each Player;
        All;
        Mei;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        If(Not(Array Contains(First Of((Event Player).self_heal_pvar), Button(Ability 1))));
            Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Append To Array, Button(Ability 1));
        End;
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Remove From Array By Value, Button(Ability 1));
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
    }
}

rule ("[mei/init.opy]: Initialize Mei") {
    event {
        Ongoing - Each Player;
        All;
        Mei;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 250);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1610);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 1.058823529411764);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Ammo(Event Player, 0, 200);
        Set Max Ammo(Event Player, 0, 200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[mercy/guardian.opy]: Detect Guardian Angel activation") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Speed Of(Event Player) >= 8.5;
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, is_using_guardian_angel, True);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Set Player Variable(Event Player, is_using_guardian_angel, False);
    }
}

rule ("[mercy/guardian.opy]: Disable jump and crouch during guardian angel") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).is_using_guardian_angel != False;
    }
    actions {
        Disallow Button(Event Player, Button(Jump));
        Disallow Button(Event Player, Button(Crouch));
        Wait Until(Not((Event Player).is_using_guardian_angel), 999999999999999);
        Allow Button(Event Player, Button(Jump));
        Allow Button(Event Player, Button(Crouch));
    }
}

rule ("[mercy/guardian.opy]: Activate GA slingshot") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).is_using_guardian_angel != False;
        "wait until below acts as the final condition for activating slingshot"
        Is Button Held(Event Player, Button(Jump)) == False;
    }
    actions {
        Wait Until(And((Event Player).is_using_guardian_angel, Is Button Held(Event Player, Button(Jump))), 999999999999999);
        "Cancel GA by pressing and unpressing button"
        Start Holding Button(Event Player, Button(Ability 1));
        Stop Holding Button(Event Player, Button(Ability 1));
        Set Player Variable(Event Player, slingshot_velocity, Velocity Of(Event Player));
        Set Player Variable(Event Player, is_slingshotting, True);
        Wait Until(Or(Not(Is Button Held(Event Player, Button(Jump))), Is On Ground(Event Player)), 0.33);
        Set Player Variable(Event Player, is_slingshotting, False);
    }
}

rule ("[mercy/guardian.opy]: Apply upwards momentum when starting slingshot") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).is_slingshotting == True;
    }
    actions {
        Apply Impulse(Event Player, Up, 6, To World, Incorporate Contrary Motion);
    }
}

rule ("[mercy/guardian.opy]: Give speed boost during slingshot") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).is_slingshotting != False;
    }
    actions {
        Apply Impulse(Event Player, (Event Player).slingshot_velocity, 0.50, To World, Incorporate Contrary Motion);
        Wait(0.016, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[mercy/guardian.opy]: Force angelic descent during slingshot") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).is_slingshotting == True;
    }
    actions {
        Allow Button(Event Player, Button(Jump));
        Start Holding Button(Event Player, Button(Jump));
        Wait Until(Not(Is Button Held(Event Player, Button(Jump))), 999999999999999);
        Stop Holding Button(Event Player, Button(Jump));
    }
}

rule ("[mercy/guardian.opy]: Slingshot GA cooldown logic") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).is_slingshotting == True;
    }
    actions {
        Set Ability 1 Enabled(Event Player, False);
        Wait Until(Or(Not(Is Button Held(Event Player, Button(Ability 1))), Is On Ground(Event Player)), 999999999999999);
        Set Ability Cooldown(Event Player, Button(Ability 1), 1.5);
        Set Ability 1 Enabled(Event Player, True);
    }
}

rule ("[mercy/resurrect.opy]: Store dead allies in an array") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Ultimate Charge Percent(Event Player) >= 100;
        Is In Spawn Room(Event Player) == False;
    }
    actions {
        Set Player Variable At Index(Event Player, resurrect_pvar, 3, Filtered Array(Players Within Radius(World Vector Of(Vector(0, 0, 0), Event Player, Rotation And Translation), 15, Team Of(Event Player), Off), Is Dead(Current Array Element)));
        Wait(0.016, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[mercy/resurrect.opy]: startMassRes()") {
    event {
        Subroutine;
        startMassRes;
    }
    actions {
        "Ult Disable"
        Set Ultimate Charge(Event Player, 0);
        "Prevent Mercy from getting ult charge"
        Set Ultimate Ability Enabled(Event Player, False);
        "eventPlayer.communicate(Comms.VOICE_LINE_UP) # Play ultimate voice line\nmass res sound eeffects"
        Play Effect(All Players(All Teams), Good Explosion, Color(Yellow), Event Player, 5);
        Play Effect(All Players(All Teams), Ring Explosion, Color(Yellow), Event Player, 5);
        Play Effect(All Players(All Teams), Buff Explosion Sound, Color(Yellow), Event Player, 5);
        "Res Player Effects"
        If(Compare((Event Player).mercy_res_id, ==, Null));
            Create Effect(All Players(All Teams), Sparkles Sound, Color(White), Event Player, 999999999999999, Visible To Position and Radius);
        End;
        Set Player Variable(Event Player, mercy_res_id, Last Created Entity);
        "Effects"
        Set Status(Event Player, Null, Phased Out, 1);
    }
}

rule ("[mercy/resurrect.opy]: stopMassRes()") {
    event {
        Subroutine;
        stopMassRes;
    }
    actions {
        "Ult enable"
        Set Ultimate Charge(Event Player, 0);
        Set Ultimate Ability Enabled(Event Player, True);
        "Gone Effects"
        Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Yellow), Event Player, 15);
        Play Effect(All Players(All Teams), Bad Explosion, Color(Yellow), Event Player, 15);
        "Clear res effects"
        Destroy Effect((Event Player).mercy_res_id);
        Set Player Variable(Event Player, mercy_res_id, Null);
    }
}

rule ("[mercy/resurrect.opy]: Trigger res") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Is Button Held(Event Player, Button(Ultimate)) == True;
        Count Of(Value In Array((Event Player).resurrect_pvar, 3)) > 0;
        Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)) == False;
        Is Alive(Event Player) == True;
    }
    actions {
        Call Subroutine(startMassRes);
        Set Player Variable At Index(Event Player, resurrect_pvar, 1, 0);
        Set Player Variable At Index(Value In Array((Event Player).resurrect_pvar, 3), resurrect_pvar, 2, True);
        Set Player Variable At Index(Event Player, resurrect_pvar, 3, Empty Array);
        Wait Until(Not(Is Using Ability 1(Event Player)), 5);
        Set Ability 1 Enabled(Event Player, False);
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
        Wait(0.65, Ignore Condition);
        Set Ability 1 Enabled(Event Player, True);
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
        Call Subroutine(stopMassRes);
    }
}

rule ("[mercy/resurrect.opy]: HUD counter") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Ultimate Charge Percent(Event Player) >= 100;
        Count Of(Value In Array((Event Player).resurrect_pvar, 3)) != Value In Array((Event Player).resurrect_pvar, 1);
        Is Alive(Event Player) == True;
        Is In Spawn Room(Event Player) == False;
    }
    actions {
        Set Player Variable At Index(Event Player, resurrect_pvar, 1, Count Of(Value In Array((Event Player).resurrect_pvar, 3)));
        If(Compare(First Of((Event Player).resurrect_pvar), ==, Null));
            Create In-World Text(Event Player, Custom String("       /  \\ \r\n     /      \\ \r\n   /  {0}×{1}\r\n  --------", Count Of(Filtered Array(Remove From Array(All Dead Players(Team Of(Event Player)), Event Player), Compare(Distance Between(Position Of(Current Array Element), Position Of(Event Player)), <=, 15))), Icon String(Skull), Null), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(1.5, World Vector Of(Up, Event Player, Rotation)), Multiply(-1.65, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 2.5, Do Not Clip, Visible To Position String and Color, Color(Yellow), Default Visibility);
        End;
        Set Player Variable At Index(Event Player, resurrect_pvar, 0, Last Text ID);
        Wait Until(Or(Not(Value In Array((Event Player).resurrect_pvar, 3)), Compare(Ultimate Charge Percent(Event Player), <, 100)), 5);
        Destroy In-World Text(First Of((Event Player).resurrect_pvar));
        Set Player Variable At Index(Event Player, resurrect_pvar, 0, Null);
        Wait(0.016, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[mercy/resurrect.opy]: Resurrected player") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).resurrect_pvar, 2) != False;
    }
    actions {
        Disable Built-In Game Mode Respawning(Event Player);
        Start Camera(Event Player, Add(Add(Eye Position(Event Player), Vector(0, 2, 0)), Multiply(Facing Direction Of(Event Player), -2)), Event Player, 0);
        Resurrect(Event Player);
        Wait(0.016, Ignore Condition);
        Start Camera(Event Player, Eye Position(Event Player), Add(Position Of(Event Player), Multiply(Facing Direction Of(Event Player), 100)), 3);
        Wait(0.016, Ignore Condition);
        Set Status(Event Player, Null, Rooted, 2.25);
        Set Status(Event Player, Null, Phased Out, 2.25);
        Set Status(Event Player, Null, Burning, 2.25);
        Play Effect(All Players(All Teams), Buff Explosion Sound, Color(Yellow), Event Player, 5);
        Wait(2.25, Ignore Condition);
        Stop Camera(Event Player);
        Set Player Variable At Index(Event Player, resurrect_pvar, 2, False);
        Enable Built-In Game Mode Respawning(Event Player);
    }
}

rule ("[mercy/resurrect.opy]: Fix bug where rez HUD applied after death") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Ultimate Charge Percent(Event Player) >= 100;
        Is Dead(Event Player) == True;
        Is In Spawn Room(Event Player) == False;
    }
    actions {
        Destroy In-World Text(First Of((Event Player).resurrect_pvar));
        Set Player Variable At Index(Event Player, resurrect_pvar, 0, Null);
        Wait(0.064, Ignore Condition);
        Loop If(Is Dead(Event Player));
    }
}

rule ("[mercy/init.opy]: Initialize Mercy") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2000);
        Set Ammo(Event Player, 0, 20);
        Set Max Ammo(Event Player, 0, 20);
        Disallow Button(Event Player, Button(Ability 2));
        Disallow Button(Event Player, Button(Ultimate));
        Set Player Variable(Event Player, is_using_guardian_angel, False);
        Set Player Variable(Event Player, is_slingshotting, False);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[mercy/init.opy]: Clean up Mercy") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Mercy);
    }
    actions {
        Wait Until(Compare(Hero Of(Event Player), !=, Hero(Mercy)), 999999999999999);
        Destroy In-World Text(First Of((Event Player).resurrect_pvar));
        Set Player Variable At Index(Event Player, resurrect_pvar, 0, Null);
    }
}

rule ("[moira/biotic_grasp.opy]: OW1 biotic grasp damage") {
    event {
        Player Dealt Damage;
        All;
        Moira;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Multiply(1.1, Divide(Event Damage, First Of((Event Player).stat_helper_pvar)))));
    }
}

rule ("[moira/coalescence.opy]: Prevent fading during coalescence") {
    event {
        Ongoing - Each Player;
        All;
        Moira;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Ability 1 Enabled(Event Player, False);
        Set Move Speed(Event Player, 92.85714285714288);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Set Move Speed(Event Player, 100);
        Set Ability 1 Enabled(Event Player, True);
    }
}

rule ("[moira/init.opy]: Initialize Moira") {
    event {
        Ongoing - Each Player;
        All;
        Moira;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2500);
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, True);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[orisa/fortify.opy]: Remove overhealth during fortify") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Damage(Event Player, Null, 181.8181818181818);
        "without this, orisa is 449/450 hp due to internal rounding"
        Heal(Event Player, Null, 1);
    }
}

rule ("[orisa/fortify.opy]: Correct movement speed during fortify") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Divide, 0.8);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Multiply, 0.8);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
    }
}

rule ("[orisa/fusion_driver.opy]: Decrease ammo when shooting gun") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Button Held(Event Player, Button(Primary Fire)) == True;
        Value In Array((Event Player).fusion_driver_pvar, 2) == False;
        Is Meleeing(Event Player) == False;
        First Of((Event Player).fusion_driver_pvar) > 0;
    }
    actions {
        Modify Player Variable At Index(Event Player, fusion_driver_pvar, 0, Subtract, 1);
        Wait(0.083333333333333, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[orisa/fusion_driver.opy]: Reload gun after respawning") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Dead(Event Player) == True;
    }
    actions {
        Wait Until(Is In Spawn Room(Event Player), 999999999999999);
        Call Subroutine(resetFusionDriver);
    }
}

rule ("[orisa/fusion_driver.opy]: Update ammo when shooting gun") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Button Held(Event Player, Button(Primary Fire)) == True;
        Value In Array((Event Player).fusion_driver_pvar, 2) == False;
    }
    actions {
        Set Ammo(Event Player, 0, Add(First Of((Event Player).fusion_driver_pvar), 1));
    }
}

rule ("[orisa/fusion_driver.opy]: Reload when out of ammo") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        First Of((Event Player).fusion_driver_pvar) <= 0;
    }
    actions {
        Call Subroutine(reloadFusionDriver);
    }
}

rule ("[orisa/fusion_driver.opy]: Reload on key press") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Button Held(Event Player, Button(Reload)) == True;
        First Of((Event Player).fusion_driver_pvar) < 200;
    }
    actions {
        Call Subroutine(reloadFusionDriver);
    }
}

rule ("[orisa/fusion_driver.opy]: reloadFusionDriver()") {
    event {
        Subroutine;
        reloadFusionDriver;
    }
    actions {
        "Abort if ammo already full"
        Abort If(Compare(First Of((Event Player).fusion_driver_pvar), >=, 200));
        "Play reload animation"
        Set Ammo(Event Player, 0, 0);
        Set Player Variable At Index(Event Player, fusion_driver_pvar, 2, True);
        Wait Until(Is Button Held(Event Player, Button(Melee)), 2.5);
        If(Is Button Held(Event Player, Button(Melee)));
            "Exit reload animation"
            Set Ammo(Event Player, 0, 201);
            Press Button(Event Player, Button(Melee));
        Else;
            Call Subroutine(resetFusionDriver);
        End;
        Set Player Variable At Index(Event Player, fusion_driver_pvar, 2, False);
    }
}

rule ("[orisa/fusion_driver.opy]: resetFusionDriver()") {
    event {
        Subroutine;
        resetFusionDriver;
    }
    actions {
        Set Max Ammo(Event Player, 0, 201);
        Set Player Variable At Index(Event Player, fusion_driver_pvar, 0, 200);
        Set Ammo(Event Player, 0, Add(First Of((Event Player).fusion_driver_pvar), 1));
    }
}

rule ("[orisa/fusion_driver.opy]: showOrisaAmmoHud()") {
    event {
        Subroutine;
        showOrisaAmmoHud;
    }
    actions {
        If(Compare(Value In Array((Event Player).fusion_driver_pvar, 1), ==, Null));
            Create In-World Text(Event Player, Custom String("{0}|{1}", Round To Integer(First Of((Event Player).fusion_driver_pvar), Up), 200, Null), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(3.3, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.5, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 2, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
            Set Player Variable At Index(Event Player, fusion_driver_pvar, 1, Last Text ID);
        End;
    }
}

rule ("[orisa/fusion_driver.opy]: hideOrisaAmmoHud()") {
    event {
        Subroutine;
        hideOrisaAmmoHud;
    }
    actions {
        Destroy In-World Text(Value In Array((Event Player).fusion_driver_pvar, 1));
        Set Player Variable At Index(Event Player, fusion_driver_pvar, 1, Null);
    }
}

rule ("[orisa/fusion_driver.opy]: Slow down Orisa when shooting") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Button Held(Event Player, Button(Primary Fire)) == True;
        Value In Array((Event Player).fusion_driver_pvar, 2) == False;
    }
    actions {
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Multiply, 0.7);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
        Wait Until(Or(Not(Is Button Held(Event Player, Button(Primary Fire))), Value In Array((Event Player).fusion_driver_pvar, 2)), 999999999999999);
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Divide, 0.7);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
    }
}

rule ("[orisa/barrier.opy]: Trigger Projectile Barrier ability") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Ability 2), 12);
        Call Subroutine(throwBarrier);
        Call Subroutine(destroyBarrier);
        Call Subroutine(deployBarrier);
    }
}

rule ("[orisa/barrier.opy]: throwBarrier()") {
    event {
        Subroutine;
        throwBarrier;
    }
    actions {
        "Initialize barrier projectile"
        Set Player Variable At Index(Event Player, barrier_pvar, 5, World Vector Of(Forward, Event Player, Rotation));
        Set Player Variable At Index(Event Player, barrier_pvar, 1, Multiply(25, Facing Direction Of(Event Player)));
        Set Player Variable At Index(Event Player, barrier_pvar, 2, Eye Position(Event Player));
        Set Player Variable(Event Player, barrier_seed_t, 0);
        Chase Player Variable At Rate(Event Player, barrier_seed_t, 12, 1, Destination and Rate);
        Set Player Variable(Event Player, barrier_seed_velocity, Value In Array((Event Player).barrier_pvar, 1));
        Chase Player Variable At Rate(Event Player, barrier_seed_velocity, Vector(X Component Of(Value In Array((Event Player).barrier_pvar, 1)), Add(Multiply(-8, (Event Player).barrier_seed_t), Y Component Of(Value In Array((Event Player).barrier_pvar, 1))), Z Component Of(Value In Array((Event Player).barrier_pvar, 1))), 9999, Destination and Rate);
        Set Player Variable(Event Player, barrier_seed_position, Value In Array((Event Player).barrier_pvar, 2));
        Chase Player Variable At Rate(Event Player, barrier_seed_position, Vector(Add(Multiply(X Component Of(Value In Array((Event Player).barrier_pvar, 1)), (Event Player).barrier_seed_t), X Component Of(Value In Array((Event Player).barrier_pvar, 2))), Add(Add(Multiply(-4, Raise To Power((Event Player).barrier_seed_t, 2)), Multiply(Y Component Of(Value In Array((Event Player).barrier_pvar, 1)), (Event Player).barrier_seed_t)), Y Component Of(Value In Array((Event Player).barrier_pvar, 2))), Add(Multiply(Z Component Of(Value In Array((Event Player).barrier_pvar, 1)), (Event Player).barrier_seed_t), Z Component Of(Value In Array((Event Player).barrier_pvar, 2)))), 9999, Destination and Rate);
        "Draw barrier projectile object"
        Create Effect(All Players(All Teams), Sphere, Color(Lime Green), (Event Player).barrier_seed_position, 0.1, Position and Radius);
        Set Player Variable At Index(Event Player, barrier_pvar, 0, Last Created Entity);
        "Wait for barrier projectile to hit wall"
        Wait Until(Update Every Frame(Compare(Distance Between((Event Player).barrier_seed_position, Ray Cast Hit Position((Event Player).barrier_seed_position, Add((Event Player).barrier_seed_position, (Event Player).barrier_seed_velocity), Null, Null, False)), <, 0.5)), 12);
        "Freeze barrier projectile"
        Stop Chasing Player Variable(Event Player, barrier_seed_t);
        Stop Chasing Player Variable(Event Player, barrier_seed_velocity);
        Stop Chasing Player Variable(Event Player, barrier_seed_position);
        "Fall down to floor after bouncing off wall"
        Set Player Variable At Index(Event Player, barrier_pvar, 3, Ray Cast Hit Normal((Event Player).barrier_seed_position, Add((Event Player).barrier_seed_position, (Event Player).barrier_seed_velocity), Null, Null, False));
        Set Player Variable At Index(Event Player, barrier_pvar, 1, Multiply(0.03, Subtract((Event Player).barrier_seed_velocity, Multiply(Multiply(2, Dot Product((Event Player).barrier_seed_velocity, Value In Array((Event Player).barrier_pvar, 3))), Value In Array((Event Player).barrier_pvar, 3)))));
        Set Player Variable At Index(Event Player, barrier_pvar, 2, (Event Player).barrier_seed_position);
        Set Player Variable(Event Player, barrier_seed_t, 0);
        Chase Player Variable At Rate(Event Player, barrier_seed_t, 12, 1, Destination and Rate);
        Set Player Variable(Event Player, barrier_seed_velocity, Value In Array((Event Player).barrier_pvar, 1));
        Chase Player Variable At Rate(Event Player, barrier_seed_velocity, Vector(X Component Of(Value In Array((Event Player).barrier_pvar, 1)), Add(Multiply(-8, (Event Player).barrier_seed_t), Y Component Of(Value In Array((Event Player).barrier_pvar, 1))), Z Component Of(Value In Array((Event Player).barrier_pvar, 1))), 9999, Destination and Rate);
        Set Player Variable(Event Player, barrier_seed_position, Value In Array((Event Player).barrier_pvar, 2));
        Chase Player Variable At Rate(Event Player, barrier_seed_position, Vector(Add(Multiply(X Component Of(Value In Array((Event Player).barrier_pvar, 1)), (Event Player).barrier_seed_t), X Component Of(Value In Array((Event Player).barrier_pvar, 2))), Add(Add(Multiply(-4, Raise To Power((Event Player).barrier_seed_t, 2)), Multiply(Y Component Of(Value In Array((Event Player).barrier_pvar, 1)), (Event Player).barrier_seed_t)), Y Component Of(Value In Array((Event Player).barrier_pvar, 2))), Add(Multiply(Z Component Of(Value In Array((Event Player).barrier_pvar, 1)), (Event Player).barrier_seed_t), Z Component Of(Value In Array((Event Player).barrier_pvar, 2)))), 9999, Destination and Rate);
        "Wait for barrier projectile to hit ground"
        Wait Until(Update Every Frame(Compare(Distance Between((Event Player).barrier_seed_position, Ray Cast Hit Position((Event Player).barrier_seed_position, Add((Event Player).barrier_seed_position, (Event Player).barrier_seed_velocity), Null, Null, False)), <, 0.5)), 12);
        "Freeze barrier projectile"
        Stop Chasing Player Variable(Event Player, barrier_seed_t);
        Stop Chasing Player Variable(Event Player, barrier_seed_velocity);
        Stop Chasing Player Variable(Event Player, barrier_seed_position);
        "Move projectile to where it collided with the ground"
        Set Player Variable(Event Player, barrier_seed_position, Ray Cast Hit Position((Event Player).barrier_seed_position, Add((Event Player).barrier_seed_position, (Event Player).barrier_seed_velocity), Null, Null, False));
        "Destroy projectile"
        Destroy Effect(First Of((Event Player).barrier_pvar));
    }
}

rule ("[orisa/barrier.opy]: deployBarrier()") {
    event {
        Subroutine;
        deployBarrier;
    }
    actions {
        "Define barrer by the sphere center position"
        Set Player Variable At Index(Event Player, barrier_pvar, 4, Subtract((Event Player).barrier_seed_position, Multiply(3.5, Value In Array((Event Player).barrier_pvar, 5))));
        "Debug barrier center\ncreateEffect(eventPlayer, Effect.SPHERE, Color.BLACK, eventPlayer._barrier_origin, 0.5, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)"
        Call Subroutine(fibonacciSphere);
        "Draw each barrier sample"
        For Global Variable(barrier_i, 0, Count Of((Event Player).barrier_entity_positions), 1);
            Create Effect(All Players(All Teams), Sphere, Value In Array((Event Player).barrier_entity_colors, Evaluate Once(Global.barrier_i)), Value In Array((Event Player).barrier_entity_positions, Evaluate Once(Global.barrier_i)), Global.ORISA_BARRIER_ORB_SIZE, Color);
            Modify Player Variable At Index(Event Player, barrier_pvar, 9, Append To Array, Last Created Entity);
        End;
        "Play barrier deploying sound"
        Play Effect(All Players(All Teams), Buff Impact Sound, Color(Lime Green), (Event Player).barrier_seed_position, 100);
        Set Player Variable At Index(Event Player, barrier_pvar, 10, True);
        Set Player Variable At Index(Event Player, barrier_pvar, 11, 900);
        Set Player Variable(Event Player, barrier_uptime, 0);
        Chase Player Variable At Rate(Event Player, barrier_uptime, 20, 1, None);
        Call Subroutine(updateBarrierVisual);
        Call Subroutine(createBarrierHud);
    }
}

rule ("[orisa/barrier.opy]: fibonacciSphere()") {
    event {
        Subroutine;
        fibonacciSphere;
    }
    actions {
        "Evenly distribute N points around a sphere\nStore coodrindate of those points to barrier_entity_positions array\nSee https://stackoverflow.com/a/26127012 for algorithm"
        Set Player Variable(Event Player, barrier_entity_positions, Empty Array);
        For Global Variable(barrier_i, 0, Global.ORISA_BARRIER_ORB_COUNT, 1);
            Set Player Variable At Index(Event Player, barrier_pvar, 6, Subtract(1, Multiply(Divide(Global.barrier_i, Subtract(Global.ORISA_BARRIER_ORB_COUNT, 1)), 2)));
            If(Compare(Value In Array((Event Player).barrier_pvar, 6), <, -0.2));
                "Do not draw bottom half of sphere"
                Break;
            End;
            Set Player Variable At Index(Event Player, barrier_pvar, 7, Square Root(Subtract(1, Raise To Power(Value In Array((Event Player).barrier_pvar, 6), 2))));
            Set Player Variable At Index(Event Player, barrier_pvar, 8, Vector(Multiply(Cosine From Radians(Multiply(3.883222077450933, Global.barrier_i)), Value In Array((Event Player).barrier_pvar, 7)), Value In Array((Event Player).barrier_pvar, 6), Multiply(Sine From Radians(Multiply(3.883222077450933, Global.barrier_i)), Value In Array((Event Player).barrier_pvar, 7))));
            Skip If(Compare(Angle Between Vectors(Value In Array((Event Player).barrier_pvar, 8), Value In Array((Event Player).barrier_pvar, 5)), >, 90), 1);
            Modify Player Variable(Event Player, barrier_entity_positions, Append To Array, Add(Value In Array((Event Player).barrier_pvar, 4), Multiply(3.5, Value In Array((Event Player).barrier_pvar, 8))));
            //__label_continue_2__:
        End;
    }
}

rule ("[orisa/barrier.opy]: destroyBarrier()") {
    event {
        Subroutine;
        destroyBarrier;
    }
    actions {
        For Global Variable(barrier_i, 0, Count Of(Value In Array((Event Player).barrier_pvar, 9)), 1);
            Destroy Effect(Value In Array(Value In Array((Event Player).barrier_pvar, 9), Global.barrier_i));
        End;
        Set Player Variable At Index(Event Player, barrier_pvar, 9, Empty Array);
        Set Player Variable(Event Player, barrier_entity_positions, Empty Array);
        Set Player Variable At Index(Event Player, barrier_pvar, 10, False);
        Call Subroutine(destroyBarrierHud);
    }
}

rule ("[orisa/barrier.opy]: Destroy barrier on barrier timeout") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).barrier_uptime >= 20;
    }
    actions {
        Stop Chasing Player Variable(Event Player, barrier_uptime);
        Call Subroutine(destroyBarrier);
    }
}

rule ("[orisa/barrier.opy]: Destroy barrier when barrier hp runs out") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Value In Array((Event Player).barrier_pvar, 11) <= 0;
    }
    actions {
        Stop Chasing Player Variable(Event Player, barrier_uptime);
        Call Subroutine(destroyBarrier);
    }
}

rule ("[orisa/barrier.opy]: Deal no damage to enemies behind barrier") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Multiply(Distance Between(Eye Position(Event Player), Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 4)), Sine From Degrees(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 4))))) <= 3.5;
        Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 4))) < 90;
        Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 10) != False;
    }
    actions {
        If(Compare(Value In Array((Event Player).barrier_pvar, 14), ==, Null));
            Start Damage Modification(Value In Array((Event Player).barrier_pvar, 16), Event Player, 1, Receivers Damagers and Damage Percent);
            Set Player Variable At Index(Event Player, barrier_pvar, 14, Last Damage Modification ID);
        End;
        While(And(And(Compare(Multiply(Distance Between(Eye Position(Event Player), Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 4)), Sine From Degrees(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 4))))), <=, 3.5), Compare(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 4))), <, 90)), Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 10)));
            Set Player Variable At Index(Event Player, barrier_pvar, 16, Empty Array);
            "Scan all enemies in front"
            Set Player Variable At Index(Event Player, barrier_pvar, 15, Players in View Angle(Event Player, Opposite Team Of(Team Of(Event Player)), 90));
            For Global Variable(los_i, 0, Count Of(Value In Array((Event Player).barrier_pvar, 15)), 1);
                Set Player Variable At Index(Event Player, hit_detection_pvar, 0, Eye Position(Event Player));
                Set Player Variable At Index(Event Player, hit_detection_pvar, 3, Direction Towards(Eye Position(Event Player), Eye Position(Value In Array(Value In Array((Event Player).barrier_pvar, 15), Global.los_i))));
                Set Player Variable At Index(Event Player, hit_detection_pvar, 1, Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 4));
                Set Player Variable At Index(Event Player, hit_detection_pvar, 2, 3.5);
                Call Subroutine(findLineSphereIntersection);
                Set Player Variable At Index(Event Player, barrier_pvar, 13, Filtered Array(Value In Array((Event Player).hit_detection_pvar, 6), And(Compare(Angle Between Vectors(Up, Direction Towards(Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 4), Current Array Element)), <=, 90), Compare(Angle Between Vectors(Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 5), Direction Towards(Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 4), Current Array Element)), <=, 90))));
                For Global Variable(los_j, 0, Count Of(Value In Array((Event Player).barrier_pvar, 13)), 1);
                    "barrier hit is between the attacker and the victim"
                    If(Compare(Distance Between(Eye Position(Event Player), Value In Array(Value In Array((Event Player).barrier_pvar, 13), Global.los_j)), <, Distance Between(Eye Position(Event Player), Eye Position(Value In Array(Value In Array((Event Player).barrier_pvar, 15), Global.los_i)))));
                        Modify Player Variable At Index(Event Player, barrier_pvar, 16, Append To Array, Value In Array(Value In Array((Event Player).barrier_pvar, 15), Global.los_i));
                        Break;
                    End;
                End;
            End;
            Wait(Divide(1, Global.ORISA_BARRIER_LOS_FREQ), Ignore Condition);
        End;
        Stop Damage Modification(Value In Array((Event Player).barrier_pvar, 14));
        Set Player Variable At Index(Event Player, barrier_pvar, 14, Null);
        Set Player Variable At Index(Event Player, barrier_pvar, 16, Empty Array);
    }
}

rule ("[orisa/barrier.opy]: Normal damage when no barrier active") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 10) == False;
    }
    actions {
        Stop Damage Modification(Value In Array((Event Player).barrier_pvar, 14));
        Set Player Variable At Index(Event Player, barrier_pvar, 14, Null);
    }
}

rule ("[orisa/barrier.opy]: Decrease barrier health") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Array Contains(Value In Array((Event Player).barrier_pvar, 16), Victim) == True;
        Value In Array((Value In Array((Event Player).reset_pvar, 5)).barrier_pvar, 10) != False;
    }
    actions {
        Modify Player Variable At Index(Value In Array((Event Player).reset_pvar, 5), barrier_pvar, 11, Subtract, Divide(If-Then-Else(Event Was Critical Hit, Divide(Event Damage, 2), Event Damage), 0.01));
    }
}

rule ("[orisa/barrier.opy]: createBarrierHud()") {
    event {
        Subroutine;
        createBarrierHud;
    }
    actions {
        Create Progress Bar HUD Text(Event Player, Multiply(100, Divide(Value In Array((Event Player).barrier_pvar, 11), 900)), Custom String("{0}", Round To Integer(Value In Array((Event Player).barrier_pvar, 11), Up), Null, Null), Top, 999999999999999, Color(Sky Blue), Color(White), Values, Default Visibility);
        Set Player Variable At Index(Event Player, barrier_pvar, 12, Last Text ID);
    }
}

rule ("[orisa/barrier.opy]: destroyBarrierHud()") {
    event {
        Subroutine;
        destroyBarrierHud;
    }
    actions {
        Destroy Progress Bar HUD Text(Value In Array((Event Player).barrier_pvar, 12));
    }
}

rule ("[orisa/barrier.opy]: updateBarrierVisual()") {
    event {
        Subroutine;
        updateBarrierVisual;
    }
    actions {
        For Global Variable(barrier_i, 0, Count Of((Event Player).barrier_entity_positions), 1);
            Set Player Variable At Index(Event Player, barrier_entity_colors, Global.barrier_i, If-Then-Else(Compare(Random Real(0, 1), <=, Divide(Value In Array((Event Player).barrier_pvar, 11), 900)), Team Of(Event Player), Color(White)));
            Wait(0.016, Ignore Condition);
        End;
    }
}

rule ("[orisa/barrier.opy]: Crack Barrier at half health") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Value In Array((Event Player).barrier_pvar, 11) <= 450;
    }
    actions {
        Call Subroutine(updateBarrierVisual);
    }
}

rule ("[orisa/barrier.opy]: Crack Barrier at quarter health") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Value In Array((Event Player).barrier_pvar, 11) <= 225;
    }
    actions {
        Call Subroutine(updateBarrierVisual);
    }
}

rule ("[orisa/halt.opy]: Trigger Halt ability") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
        Ability Cooldown(Event Player, Button(Secondary Fire)) <= 0;
        Is Alive(Event Player) == True;
        Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)) == False;
    }
    actions {
        Call Subroutine(shootHalt);
        "Ensure player releases right click"
        Wait Until(Not(Is Button Held(Event Player, Button(Secondary Fire))), 999999999999999);
        "Detect halt pull activation on right click"
        Wait Until(Update Every Frame(Or(And(And(Is Button Held(Event Player, Button(Secondary Fire)), Is Alive(Event Player)), Not(Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)))), Compare((Event Player).halt_position, ==, (Event Player).halt_ending_position))), 999999999999999);
        Call Subroutine(explodeHalt);
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 8);
    }
}

rule ("[orisa/halt.opy]: Shoot Halt Orb") {
    event {
        Subroutine;
        shootHalt;
    }
    actions {
        "Start halt"
        Set Player Variable At Index(Event Player, halt_pvar, 0, True);
        "Halt orb visuals"
        If(Compare(Value In Array((Event Player).halt_pvar, 3), ==, Null));
            Create Effect(All Players(All Teams), Sphere, Color(Lime Green), (Event Player).halt_position, 0.6, Visible To Position and Radius);
            Set Player Variable At Index(Event Player, halt_pvar, 3, Last Created Entity);
        End;
        If(Compare(Value In Array((Event Player).halt_pvar, 4), ==, Null));
            Create Effect(All Players(All Teams), Sphere, Color(Lime Green), (Event Player).halt_position, 0.3, Visible To Position and Radius);
            Set Player Variable At Index(Event Player, halt_pvar, 4, Last Created Entity);
        End;
        "Halt orb sounds"
        Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Lime Green), Event Player, 100);
        "Calculate starting/ending positions"
        Set Player Variable(Event Player, halt_position, Eye Position(Event Player));
        Set Player Variable(Event Player, halt_ending_position, Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(1000, Facing Direction Of(Event Player))), Null, Null, True));
        Set Player Variable At Index(All Players(Opposite Team Of(Team Of(Event Player))), halt_pvar, 1, False);
        Wait(0.1, Ignore Condition);
        "Start flying halt orb"
        Chase Player Variable At Rate(Event Player, halt_position, (Event Player).halt_ending_position, 25, Destination and Rate);
    }
}

rule ("[orisa/halt.opy]: Explode Halt Orb") {
    event {
        Subroutine;
        explodeHalt;
    }
    actions {
        Stop Chasing Player Variable(Event Player, halt_position);
        Wait(0.45, Ignore Condition);
        Set Player Variable At Index(Event Player, halt_pvar, 2, Players Within Radius((Event Player).halt_position, 7, Opposite Team Of(Team Of(Event Player)), Surfaces And All Barriers));
        Set Player Variable At Index(Value In Array((Event Player).halt_pvar, 2), halt_pvar, 1, True);
        Set Environment Credit Player(Value In Array((Event Player).halt_pvar, 2), Event Player);
        "Halt orb explosion sounds"
        Play Effect(All Players(All Teams), Explosion Sound, Color(Lime Green), Event Player, 100);
        "Clear visuals"
        Destroy Effect(Value In Array((Event Player).halt_pvar, 3));
        Set Player Variable At Index(Event Player, halt_pvar, 3, Null);
        Destroy Effect(Value In Array((Event Player).halt_pvar, 4));
        Set Player Variable At Index(Event Player, halt_pvar, 4, Null);
        Set Player Variable At Index(Event Player, halt_pvar, 0, False);
    }
}

rule ("[orisa/halt.opy]: Slow down snared enemies") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).halt_pvar, 1) != False;
    }
    actions {
        Set Move Speed(Event Player, 33);
        Wait(0.65, Ignore Condition);
        Set Move Speed(Event Player, 100);
    }
}

rule ("[orisa/halt.opy]: Pull halted victims") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).halt_pvar, 1) != False;
    }
    actions {
        Set Player Variable(Event Player, position, Position Of(Event Player));
        Start Forcing Player Position(Event Player, (Event Player).position, True);
        Chase Player Variable At Rate(Event Player, position, (Value In Array((Event Player).reset_pvar, 5)).halt_position, 20, Destination and Rate);
        Wait Until(Compare((Event Player).position, ==, (Value In Array((Event Player).reset_pvar, 5)).halt_position), 999999999999999);
        Stop Chasing Player Variable(Event Player, position);
        Stop Forcing Player Position(Event Player);
        Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
        Set Player Variable At Index(Event Player, halt_pvar, 1, False);
    }
}

rule ("[orisa/halt.opy]: Halt snare line VFX") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Value In Array((Event Player).reset_pvar, 5)).halt_pvar) != False;
        Distance Between(Divide(Add(Position Of(Event Player), Eye Position(Event Player)), 2), (Value In Array((Event Player).reset_pvar, 5)).halt_position) <= 7;
        Is In Line of Sight(Divide(Add(Position Of(Event Player), Eye Position(Event Player)), 2), (Value In Array((Event Player).reset_pvar, 5)).halt_position, All Barriers Block LOS) == True;
        Is Alive(Event Player) == True;
    }
    actions {
        "Halt orb explosion sounds"
        Call Subroutine(showSnareLine);
        Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Lime Green), Event Player, 100);
        Wait Until(Not(And(And(And(First Of((Value In Array((Event Player).reset_pvar, 5)).halt_pvar), Compare(Distance Between(Divide(Add(Position Of(Event Player), Eye Position(Event Player)), 2), (Value In Array((Event Player).reset_pvar, 5)).halt_position), <=, 7)), Is In Line of Sight(Divide(Add(Position Of(Event Player), Eye Position(Event Player)), 2), (Value In Array((Event Player).reset_pvar, 5)).halt_position, All Barriers Block LOS)), Is Alive(Event Player))), 999999999999999);
        Call Subroutine(hideSnareLine);
    }
}

rule ("[orisa/halt.opy]: showSnareLine()") {
    event {
        Subroutine;
        showSnareLine;
    }
    actions {
        If(Compare(Value In Array((Event Player).halt_pvar, 5), ==, Null));
            Create Beam Effect(If-Then-Else(And(And(And(First Of((Value In Array((Event Player).reset_pvar, 5)).halt_pvar), Compare(Distance Between(Divide(Add(Position Of(Event Player), Eye Position(Event Player)), 2), (Value In Array((Event Player).reset_pvar, 5)).halt_position), <=, 7)), Is In Line of Sight(Divide(Add(Position Of(Event Player), Eye Position(Event Player)), 2), (Value In Array((Event Player).reset_pvar, 5)).halt_position, All Barriers Block LOS)), Is Alive(Event Player)), All Players(All Teams), Null), Good Beam, (Value In Array((Event Player).reset_pvar, 5)).halt_position, Divide(Add(Position Of(Event Player), Eye Position(Event Player)), 2), If-Then-Else(Value In Array((Event Player).halt_pvar, 1), Color(Green), Color(White)), Visible To Position Radius and Color);
            Set Player Variable At Index(Event Player, halt_pvar, 5, Last Created Entity);
        End;
    }
}

rule ("[orisa/halt.opy]: hideSnareLine()") {
    event {
        Subroutine;
        hideSnareLine;
    }
    actions {
        Destroy Effect(Value In Array((Event Player).halt_pvar, 5));
        Set Player Variable At Index(Event Player, halt_pvar, 5, Null);
    }
}

rule ("[orisa/halt.opy]: Destroy Halt pull line vfx when halt starts") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Value In Array((Event Player).reset_pvar, 5)).halt_pvar) != False;
    }
    actions {
        Destroy Effect(Value In Array((Event Player).halt_pvar, 5));
        Set Player Variable At Index(Event Player, halt_pvar, 5, Null);
    }
}

rule ("[orisa/halt.opy]: Destroy Halt pull line vfx when halt is over") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Value In Array((Event Player).reset_pvar, 5)).halt_pvar) == False;
    }
    actions {
        Destroy Effect(Value In Array((Event Player).halt_pvar, 5));
        Set Player Variable At Index(Event Player, halt_pvar, 5, Null);
    }
}

rule ("[orisa/halt.opy]: Destroy Halt pull line vfx when dead") {
    event {
        Player Died;
        All;
        All;
    }
    conditions {
        First Of((Value In Array((Event Player).reset_pvar, 5)).halt_pvar) != False;
    }
    actions {
        Destroy Effect(Value In Array((Event Player).halt_pvar, 5));
        Set Player Variable At Index(Event Player, halt_pvar, 5, Null);
    }
}

rule ("[orisa/supercharger.opy]: play Terra Surge voiceline") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Button Held(Event Player, Button(Ultimate)) == True;
        Ultimate Charge Percent(Event Player) >= 100;
    }
    actions {
        Allow Button(Event Player, Button(Ultimate));
        Set Status(Players Within Radius(Event Player, 9, Opposite Team Of(Team Of(Event Player)), Surfaces), Null, Phased Out, 0.016);
        Press Button(Event Player, Button(Ultimate));
        Disallow Button(Event Player, Button(Ultimate));
    }
}

rule ("[orisa/supercharger.opy]: Trigger Supercharger start") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        "Stop Terra Surge animation"
        Cancel Primary Action(Event Player);
        If(Is Using Ability 1(Event Player));
            "Remove shield gained from Terra Surge"
            Damage(Event Player, Null, 181.8181818181818);
        End;
        "Destroy any existing Supercharger"
        Call Subroutine(endSupercharger);
        Wait Until(Is On Ground(Event Player), 999999999999999);
        "Start new supercharger"
        Call Subroutine(startSupercharger);
        "Start supercharger timer"
        Wait(15, Restart When True);
        Call Subroutine(endSupercharger);
    }
}

rule ("[orisa/supercharger.opy]: startSupercharger()") {
    event {
        Subroutine;
        startSupercharger;
    }
    actions {
        Set Player Variable At Index(Event Player, supercharger_pvar, 4, Add(Position Of(Event Player), Multiply(0.5, Up)));
        Set Ultimate Charge(Event Player, 0);
        "Prevent Orisa from getting ult charge"
        Set Ultimate Ability Enabled(Event Player, False);
        "Play ultimate voice line"
        Communicate(Event Player, Voice Line Up);
        "Supercharge GUI"
        If(Compare(Value In Array((Event Player).supercharger_pvar, 2), ==, Null));
            Create Effect(All Players(All Teams), Sphere, Color(Lime Green), Add(Value In Array((Event Player).supercharger_pvar, 4), Multiply(0.25, Up)), 0.333333333333333, None);
            Set Player Variable At Index(Event Player, supercharger_pvar, 2, Last Created Entity);
        End;
        If(Compare(Value In Array((Event Player).supercharger_pvar, 3), ==, Null));
            Create Effect(All Players(All Teams), Sphere, Color(Lime Green), Add(Value In Array((Event Player).supercharger_pvar, 4), Multiply(0.25, Down)), 0.333333333333333, None);
            Set Player Variable At Index(Event Player, supercharger_pvar, 3, Last Created Entity);
        End;
        "Supercharger deploy effect"
        Play Effect(All Players(All Teams), Good Explosion, Color(Green), Value In Array((Event Player).supercharger_pvar, 4), 3);
        Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Green), Value In Array((Event Player).supercharger_pvar, 4), 200);
        "Announce supercharger active"
        Set Player Variable At Index(Event Player, supercharger_pvar, 0, True);
    }
}

rule ("[orisa/supercharger.opy]: endSupercharger()") {
    event {
        Subroutine;
        endSupercharger;
    }
    actions {
        Set Ultimate Ability Enabled(Event Player, True);
        Destroy Effect(Value In Array((Event Player).supercharger_pvar, 2));
        Set Player Variable At Index(Event Player, supercharger_pvar, 2, Null);
        Destroy Effect(Value In Array((Event Player).supercharger_pvar, 3));
        Set Player Variable At Index(Event Player, supercharger_pvar, 3, Null);
        Set Player Variable At Index(Event Player, supercharger_pvar, 0, False);
        Set Player Variable At Index(All Players(Team Of(Event Player)), supercharger_pvar, 1, False);
    }
}

rule ("[orisa/supercharger.opy]: Supercharge teammates in supercharger range") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Value In Array((Event Player).reset_pvar, 2)).supercharger_pvar) != False;
        Distance Between(Event Player, Value In Array((Value In Array((Event Player).reset_pvar, 2)).supercharger_pvar, 4)) <= 25;
        Is In Line of Sight(Event Player, Value In Array((Value In Array((Event Player).reset_pvar, 2)).supercharger_pvar, 4), Barriers Do Not Block LOS) == True;
        Is Alive(Event Player) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, supercharger_pvar, 1, True);
    }
}

rule ("[orisa/supercharger.opy]: De-supercharge teammates outside supercharger range") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Value In Array((Event Player).reset_pvar, 2)).supercharger_pvar) != False;
        Value In Array((Event Player).supercharger_pvar, 1) != False;
        And(Compare(Distance Between(Event Player, Value In Array((Value In Array((Event Player).reset_pvar, 2)).supercharger_pvar, 4)), <=, 25), Is In Line of Sight(Event Player, Value In Array((Value In Array((Event Player).reset_pvar, 2)).supercharger_pvar, 4), Barriers Do Not Block LOS)) == False;
    }
    actions {
        Wait(1, Abort When False);
        Set Player Variable At Index(Event Player, supercharger_pvar, 1, False);
    }
}

rule ("[orisa/supercharger.opy]: De-supercharge teammates when supercharger ends") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        First Of((Event Player).supercharger_pvar) == False;
    }
    actions {
        Set Player Variable At Index(All Players(Team Of(Event Player)), supercharger_pvar, 1, False);
    }
}

rule ("[orisa/supercharger.opy]: De-supercharge teammates when they die") {
    event {
        Player Died;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).supercharger_pvar, 1) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, supercharger_pvar, 1, False);
    }
}

rule ("[orisa/supercharger.opy]: Damage boost player when supercharged") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).supercharger_pvar, 1) != False;
    }
    actions {
        Set Damage Dealt(Event Player, Multiply(100, Multiply(1.5, First Of((Event Player).stat_helper_pvar))));
        "Beam and sound effects\nbeam"
        If(Compare(Value In Array((Event Player).supercharger_pvar, 5), ==, Null));
            Create Beam Effect(All Players(All Teams), Good Beam, Value In Array((Value In Array((Event Player).reset_pvar, 2)).supercharger_pvar, 4), Divide(Add(Position Of(Event Player), Eye Position(Event Player)), 2), Color(Blue), Visible To Position and Radius);
            Set Player Variable At Index(Event Player, supercharger_pvar, 5, Last Created Entity);
        End;
        "sound"
        If(Compare(Value In Array((Event Player).supercharger_pvar, 6), ==, Null));
            Create Effect(Event Player, Energy Sound, Color(Green), Position Of(Event Player), 100, Position and Radius);
            Set Player Variable At Index(Event Player, supercharger_pvar, 6, Last Created Entity);
    }
}

rule ("[orisa/supercharger.opy]: Revert damage boost if not supercharged") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).supercharger_pvar, 1) == False;
    }
    actions {
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        "Beam and sound effects"
        Destroy Effect(Value In Array((Event Player).supercharger_pvar, 5));
        Set Player Variable At Index(Event Player, supercharger_pvar, 5, Null);
        Destroy Effect(Value In Array((Event Player).supercharger_pvar, 6));
        Set Player Variable At Index(Event Player, supercharger_pvar, 6, Null);
    }
}

rule ("[orisa/init.opy]: Initialize Orisa") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1680);
        "Below variables are also declared and initialized in reset_hero.opy"
        Set Player Variable At Index(All Players(Team Of(Event Player)), reset_pvar, 2, Event Player);
        Set Player Variable At Index(All Players(Opposite Team Of(Team Of(Event Player))), reset_pvar, 5, Event Player);
        Disallow Button(Event Player, Button(Ultimate));
        Set Player Variable At Index(Event Player, supercharger_pvar, 0, False);
        Disallow Button(Event Player, Button(Secondary Fire));
        Set Player Variable At Index(Event Player, halt_pvar, 0, False);
        Disallow Button(Event Player, Button(Ability 2));
        Call Subroutine(resetFusionDriver);
        Call Subroutine(showOrisaAmmoHud);
        Set Player Variable At Index(Event Player, fusion_driver_pvar, 2, False);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 0.846153846153846);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Projectile Speed(Event Player, 120);
        Set Knockback Received(Event Player, 200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
    }
}

rule ("[orisa/init.opy]: Clean up Orisa") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Orisa);
    }
    actions {
        Wait Until(Compare(Hero Of(Event Player), !=, Hero(Orisa)), 999999999999999);
        Call Subroutine(destroyBarrier);
        Call Subroutine(endSupercharger);
        Call Subroutine(hideOrisaAmmoHud);
    }
}

rule ("[pharah/rocket_launcher.opy]: OW1 Pharah fire rate") {
    event {
        Ongoing - Each Player;
        All;
        Pharah;
    }
    conditions {
        Is Firing Primary(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Primary Fire));
        Wait(0.85, Ignore Condition);
        Allow Button(Event Player, Button(Primary Fire));
        If(Is Button Held(Event Player, Button(Primary Fire)));
            Press Button(Event Player, Button(Primary Fire));
    }
}

rule ("[pharah/concussive.opy]: Remove OW2 Concussive Blast damage") {
    event {
        Player Dealt Damage;
        All;
        Pharah;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Heal(Victim, Null, Event Damage);
    }
}

rule ("[pharah/barrage.opy]: get barrage ammo") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).ammo != Ammo(Event Player, 0);
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Wait(0.016, Abort When False);
        Set Player Variable(Event Player, ammo, Ammo(Event Player, 0));
    }
}

rule ("[pharah/barrage.opy]: set barrage ammo") {
    event {
        Ongoing - Each Player;
        All;
        Pharah;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Ammo(Event Player, 0, (Event Player).ammo);
    }
}

rule ("[pharah/init.opy]: Initialize Pharah") {
    event {
        Ongoing - Each Player;
        All;
        Pharah;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Secondary Fire Enabled(Event Player, False);
        Set Knockback Dealt(Event Player, 144.44444444444443);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[ramattra/annihilation.opy]: start ult and chase variables") {
    event {
        Ongoing - Each Player;
        All;
        Ramattra;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, ult_duration, Global.ULT_DURATION_WORKSHOP_SETTINGS);
        Create Progress Bar HUD Text(Event Player, Multiply((Event Player).ult_duration, Divide(100, Global.ULT_DURATION_MAX)), Custom String("{0}s", Round To Integer((Event Player).ult_duration, To Nearest), Null, Null), Top, 1000, Color(White), Color(White), Visible To Values and Color, Visible Never);
        Set Player Variable(Event Player, ram_progress_bar, Last Text ID);
        Chase Player Variable At Rate(Event Player, ult_duration, 0, 1, Destination and Rate);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Stop Chasing Player Variable(Event Player, ult_duration);
        Destroy Progress Bar HUD Text((Event Player).ram_progress_bar);
        Set Player Variable(Event Player, ult_duration, Global.ULT_DURATION_WORKSHOP_SETTINGS);
    }
}

rule ("[ramattra/annihilation.opy]: dealt dmg stop chase variables") {
    event {
        Player Dealt Damage;
        All;
        Ramattra;
    }
    conditions {
        Event Ability == Button(Ultimate);
        Event Ability != Button(Primary Fire);
        Event Ability != Button(Ability 2);
        Event Ability != Button(Melee);
        Event Ability != Null;
    }
    actions {
        Stop Chasing Player Variable(Event Player, ult_duration);
        Wait(0.016, Restart When True);
        Chase Player Variable At Rate(Event Player, ult_duration, 0, 1, Destination and Rate);
    }
}

rule ("[ramattra/annihilation.opy]: stop ult if varb hits 0") {
    event {
        Ongoing - Each Player;
        All;
        Ramattra;
    }
    conditions {
        (Event Player).ult_duration <= 0;
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Press Button(Event Player, Button(Ability 1));
        Wait(0.016, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[ramattra/init.opy]: Initialize Ramattra") {
    event {
        Ongoing - Each Player;
        All;
        Ramattra;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 250);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 100);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2600);
        Set Knockback Received(Event Player, 200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[reaper/reaping.opy]: if orb collected remove.") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).soul_pvar, 1) == True;
    }
    actions {
        Destroy Effect(First Of((Event Player).soul_pvar));
        Set Player Variable At Index(Event Player, soul_pvar, 0, Null);
    }
}

rule ("[reaper/reaping.opy]: spawn soul orb") {
    event {
        Player Died;
        All;
        All;
    }
    actions {
        If(Compare(First Of((Event Player).soul_pvar), ==, Null));
            Create Effect(Players On Hero(Hero(Reaper), Opposite Team Of(Team Of(Event Player))), Orb, Color(Red), Add(Update Every Frame(Position Of(Event Player)), Vector(0, 1, 0)), 0.5, Visible To Position and Radius);
            Set Player Variable At Index(Event Player, soul_pvar, 0, Last Created Entity);
            Set Player Variable At Index(Event Player, soul_pvar, 1, False);
        End;
        Wait Until(Is Alive(Event Player), 999999999999999);
        Set Player Variable At Index(Event Player, soul_pvar, 1, True);
    }
}

rule ("[reaper/reaping.opy]: collect orb") {
    event {
        Ongoing - Each Player;
        All;
        Reaper;
    }
    conditions {
        Number Of Dead Players(Opposite Team Of(Team Of(Event Player))) > 0;
        Distance Between(Position Of(Event Player), Position Of(First Of(Sorted Array(Filtered Array(All Dead Players(All Teams), Not(Value In Array((Current Array Element).soul_pvar, 1))), Current Array Element)))) < 1.5;
        Is True For Any(All Players(Opposite Team Of(Team Of(Event Player))), Compare(Value In Array((Current Array Element).soul_pvar, 1), !=, True)) == True;
        Normalized Health(Event Player) < 1;
    }
    actions {
        Set Player Variable At Index(First Of(Sorted Array(All Dead Players(Opposite Team Of(Team Of(Event Player))), Distance Between(Position Of(Event Player), Position Of(Current Array Element)))), soul_pvar, 1, True);
        Heal(Event Player, Null, 50);
        Wait(0.016, Abort When False);
        Loop If Condition Is True;
    }
}

rule ("[reaper/reaping.opy]: orb collected") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).soul_pvar, 1) == True;
        Is Dead(Event Player) == True;
    }
    actions {
        Wait(0.016, Abort When False);
        Destroy Effect(First Of((Event Player).soul_pvar));
        Set Player Variable At Index(Event Player, soul_pvar, 0, Null);
        Stop Forcing Player Position(Event Player);
        Teleport(Event Player, Vector(0, -500, 0));
    }
}

rule ("[reaper/reaping.opy]: follow players") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Dead(Event Player) == True;
        Value In Array((Event Player).soul_pvar, 1) != True;
        Number Of Heroes(Hero(Reaper), Opposite Team Of(Team Of(Event Player))) > 0;
        Is True For Any(Players On Hero(Hero(Reaper), Opposite Team Of(Team Of(Event Player))), And(And(Is Alive(Current Array Element), Compare(Distance Between(Position Of(Event Player), Position Of(Current Array Element)), <, 5)), Compare(Normalized Health(Current Array Element), <, 1))) == True;
    }
    actions {
        Wait(0.016, Abort When False);
        Set Player Variable(Event Player, orb_pos, Position Of(Event Player));
        Start Forcing Player Position(Event Player, (Event Player).orb_pos, True);
        Chase Player Variable At Rate(Event Player, orb_pos, Position Of(First Of(Sorted Array(Filtered Array(Players On Hero(Hero(Reaper), Opposite Team Of(Team Of(Event Player))), And(Is Alive(Current Array Element), Compare(Normalized Health(Current Array Element), <, 1))), Distance Between(Position Of(Event Player), Position Of(Current Array Element))))), 8, Destination and Rate);
    }
}

rule ("[reaper/reaping.opy]: stop following") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Or(Compare(Value In Array((Event Player).soul_pvar, 1), !=, True), Is Alive(Event Player)) == True;
        Or(Is True For Any(Players On Hero(Hero(Reaper), Opposite Team Of(Team Of(Event Player))), And(And(Is Alive(Current Array Element), Compare(Distance Between(Position Of(Event Player), Position Of(Current Array Element)), <, 5)), Compare(Normalized Health(Current Array Element), <, 1))), Is Alive(Event Player)) == False;
    }
    actions {
        Stop Forcing Player Position(Event Player);
        Stop Chasing Player Variable(Event Player, orb_pos);
        If(And(Is Alive(Event Player), Not(Is In Spawn Room(Event Player))));
            Wait(0.1, Ignore Condition);
            If(Not(Has Status(Event Player, Burning)));
                Teleport(Event Player, Random Value In Array(Spawn Points(Team Of(Event Player))));
    }
}

rule ("[reaper/wraith.opy]: set reaper wraith") {
    event {
        Ongoing - Each Player;
        All;
        Reaper;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Multiply, 0.75);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
        Set Ammo(Event Player, 0, (Event Player).ammo);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Divide, 0.75);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
    }
}

rule ("[reaper/init.opy]: Initialize Reaper") {
    event {
        Ongoing - Each Player;
        All;
        Reaper;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 250);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2000);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[reinhardt/hammer.opy]: Correct Hammer damage") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(1.1, Divide(Event Damage, First Of((Event Player).stat_helper_pvar))), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[reinhardt/hammer.opy]: Set move penalty for reinhardt") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Firing Primary(Event Player) == True;
    }
    actions {
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Multiply, 0.95);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
        Wait Until(Not(Is Firing Primary(Event Player)), 999999999999999);
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Divide, 0.95);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
    }
}

rule ("[reinhardt/hammer.opy]: Set move penalty for reinhardt melee") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Meleeing(Event Player) == True;
    }
    actions {
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Multiply, 0.95);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
        Wait Until(Not(Is Meleeing(Event Player)), 999999999999999);
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Divide, 0.95);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
    }
}

rule ("[reinhardt/firestrike.opy]: Force single firestrike") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 2(Event Player)), 1);
        "Every time rein uses firestrike, reset the resource to 0"
        Set Ability Charge(Event Player, Button(Ability 2), 0);
        Wait(6, Ignore Condition);
        Set Ability Charge(Event Player, Button(Ability 2), 2);
    }
}

rule ("[reinhardt/charge.opy]: Increase charge damage") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        "Checks for pin vs boop damage (+ 1 because apparently 50.0 > 50 == true for whatever reason)"
        If(Compare(Event Damage, >, 51));
            Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), 1.090909090909090), Event Damage), First Of((Event Player).stat_helper_pvar)));
        Else;
            Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[reinhardt/charge.opy]: Reduce charge radius") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Start Forcing Throttle(Event Player, 0, 0.666666666666666, 0, 0.666666666666666, 0, 0.666666666666666);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Stop Forcing Throttle(Event Player);
    }
}

rule ("[reinhardt/shatter.opy]: one shot earthshatter") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Event Ability == Button(Ultimate);
        Event Was Critical Hit == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), 1.470588235294117), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[reinhardt/shatter.opy]: earthshatter knock down duration") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Has Status(Victim, Knocked Down) == True;
    }
    actions {
        Wait(2.5, Ignore Condition);
        Clear Status(Victim, Knocked Down);
    }
}

rule ("[reinhardt/barrier.opy]: Slow down Reinhardt when using barrier") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Multiply, 0.8);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
        Wait Until(Not(Is Firing Secondary(Event Player)), 999999999999999);
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Divide, 0.8);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
    }
}

rule ("[reinhardt/init.opy]: Initialize Reinhardt") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 300);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1500);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 0.833333333333333);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        "No steadfast passive at launch"
        Set Knockback Received(Event Player, 200);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[roadhog/hook.opy]: OW1 hook damage") {
    event {
        Player Dealt Damage;
        All;
        Roadhog;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(4, Event Damage), Event Damage));
    }
}

rule ("[roadhog/breather.opy]: OW1 Take a Breather") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) <= 0;
        Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)) == False;
        Is Firing Primary(Event Player) == False;
        Is Using Ability 1(Event Player) == False;
        Is Using Ultimate(Event Player) == False;
        Is Meleeing(Event Player) == False;
    }
    actions {
        "activate ability"
        Set Player Variable At Index(Event Player, breather_pvar, 0, True);
        Set Status(Event Player, Null, Rooted, 999999999999999);
        Set Ability 2 Enabled(Event Player, False);
        "reduce damage intake"
        Set Damage Received(Event Player, 83.33333333333334);
        Allow Button(Event Player, Button(Secondary Fire));
        Set Secondary Fire Enabled(Event Player, True);
        Start Holding Button(Event Player, Button(Secondary Fire));
        Wait Until(Not(Is Firing Secondary(Event Player)), 999999999999999);
        Stop Holding Button(Event Player, Button(Secondary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        "reset damage intake"
        Set Damage Received(Event Player, 100);
        Clear Status(Event Player, Rooted);
        Wait(0.5, Ignore Condition);
        Set Player Variable At Index(Event Player, breather_pvar, 0, False);
        "cooldown"
        Set Ability 2 Enabled(Event Player, True);
        Set Secondary Fire Enabled(Event Player, False);
        Set Ability Cooldown(Event Player, Button(Ability 2), 8);
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 8);
    }
}

rule ("[roadhog/breather.opy]: Allow self healing during Breather") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        First Of((Event Player).breather_pvar) != False;
    }
    actions {
        If(Not(Array Contains(First Of((Event Player).self_heal_pvar), Button(Ability 2))));
            Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Append To Array, Button(Ability 2));
        End;
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
        Wait Until(Not(First Of((Event Player).breather_pvar)), 999999999999999);
        Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Remove From Array By Value, Button(Ability 2));
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
    }
}

rule ("[sombra/hack.opy]: Apply OW1 hack on top of OW2 hack") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Has Status(Event Player, Hacked) == True;
    }
    actions {
        Stop Chasing Player Variable(Event Player, hack_timer);
        Set Status(Event Player, Value In Array((Event Player).reset_pvar, 6), Hacked, 5);
        Set Player Variable(Event Player, hack_timer, 5);
        Chase Player Variable At Rate(Event Player, hack_timer, 0, 1, None);
    }
}

rule ("[sombra/hack.opy]: Reset hack if has stealth passive") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Wait(1.625, Abort When False);
        Damage(Event Player, Null, 0.000001);
        Heal(Event Player, Null, 0.000001);
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
        Loop If Condition Is True;
    }
}

rule ("[roadhog/wholehog.opy]: OW1 disable abilities during wholehog") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Melee Enabled(Event Player, False);
        Set Ability 1 Enabled(Event Player, False);
        Set Ability 2 Enabled(Event Player, False);
        Set Damage Dealt(Event Player, 116.66666666666667);
        Set Knockback Dealt(Event Player, 87.5);
    }
}

rule ("[roadhog/wholehog.opy]: OW1 enable abilities when not in wholehog") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Set Melee Enabled(Event Player, True);
        Set Ability 1 Enabled(Event Player, True);
        Set Ability 2 Enabled(Event Player, True);
        Set Damage Dealt(Event Player, 100);
        Set Knockback Dealt(Event Player, 100);
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}

rule ("[roadhog/wholehog.opy]: OW1 Wholehog force autofire") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Is Button Held(Event Player, Button(Primary Fire)) == False;
    }
    actions {
        Start Holding Button(Event Player, Button(Primary Fire));
    }
}

rule ("[roadhog/wholehog.opy]: Cancel ult when stunned") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)) == True;
    }
    actions {
        If(Compare((Event Player).hack_timer, >, 0));
        Else If(Has Status(Event Player, Frozen));
            Wait Until(Not(Has Status(Event Player, Frozen)), 999999999999999);
        Else If(Has Status(Event Player, Knocked Down));
            Wait Until(Not(Has Status(Event Player, Knocked Down)), 999999999999999);
        Else If(Has Status(Event Player, Asleep));
            Wait Until(Not(Has Status(Event Player, Asleep)), 999999999999999);
        Else If(Has Status(Event Player, Stunned));
            Wait Until(Not(Has Status(Event Player, Stunned)), 999999999999999);
        End;
        If(Is Using Ultimate(Event Player));
            Set Player Variable At Index(Event Player, wholehog_pvar, 4, Ammo(Event Player, 0));
            Call Subroutine(cancelWholehog);
    }
}

rule ("[roadhog/wholehog.opy]: Reduce ultimate duration") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Wait(6, Abort When False);
        Set Player Variable At Index(Event Player, wholehog_pvar, 4, 4);
        Call Subroutine(cancelWholehog);
    }
}

rule ("[roadhog/wholehog.opy]: cancelWholehog()") {
    event {
        Subroutine;
        cancelWholehog;
    }
    actions {
        Stop Holding Button(Event Player, Button(Primary Fire));
        "Save hog state"
        Set Player Variable At Index(Event Player, reset_pvar, 1, Health(Event Player));
        Set Player Variable At Index(Event Player, wholehog_pvar, 2, Ability Cooldown(Event Player, Button(Ability 1)));
        Set Player Variable At Index(Event Player, wholehog_pvar, 3, Ability Cooldown(Event Player, Button(Ability 2)));
        Set Player Variable At Index(Event Player, wholehog_pvar, 0, True);
        Start Forcing Player To Be Hero(Event Player, Hero(Zarya));
    }
}

rule ("[roadhog/wholehog.opy]: Go back to roadhog") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Event Player).wholehog_pvar) != False;
    }
    actions {
        Start Forcing Player To Be Hero(Event Player, Hero(Roadhog));
        Stop Forcing Player To Be Hero(Event Player);
        Call Subroutine(applyCustomHp);
        Set Player Health(Event Player, Value In Array((Event Player).reset_pvar, 1));
        Set Ability Cooldown(Event Player, Button(Ability 1), Value In Array((Event Player).wholehog_pvar, 2));
        Set Ability Cooldown(Event Player, Button(Ability 2), Value In Array((Event Player).wholehog_pvar, 3));
        Set Ammo(Event Player, 0, Value In Array((Event Player).wholehog_pvar, 4));
        "Without this, hog gets his ow2 clip size back"
        Set Max Ammo(Event Player, 0, 4);
        Set Player Variable At Index(Event Player, wholehog_pvar, 0, False);
    }
}

rule ("[roadhog/scrap_gun.opy]: OW1 Scrap Gun secondary fire") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
        Or(Not(Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down))), Compare((Event Player).hack_timer, >, 0)) == True;
        Is Firing Primary(Event Player) == False;
        Is Firing Secondary(Event Player) == False;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
        First Of((Event Player).breather_pvar) == False;
        Is Using Ultimate(Event Player) == False;
        Is Meleeing(Event Player) == False;
        Is Reloading(Event Player) == False;
        Ammo(Event Player, 0) > 0;
        Subtract(Total Time Elapsed, Value In Array((Event Player).scrap_gun_pvar, 4)) > 1;
    }
    actions {
        Set Player Variable At Index(Event Player, scrap_gun_pvar, 4, Total Time Elapsed);
        Set Player Variable At Index(Event Player, scrap_gun_pvar, 5, Eye Position(Event Player));
        Set Ammo(Event Player, 0, Subtract(Ammo(Event Player, 0), 1));
        Set Player Variable At Index(Event Player, scrap_gun_pvar, 3, Facing Direction Of(Event Player));
        Create Projectile(Orb Projectile, Event Player, Eye Position(Event Player), Value In Array((Event Player).scrap_gun_pvar, 3), To World, Damage, Opposite Team Of(Team Of(Event Player)), 50, 1, 0, Good Explosion, Explosion Sound, 0.001, 80, 0.1, 0, 0, 0);
        Set Player Variable At Index(Event Player, scrap_gun_pvar, 0, Ray Cast Hit Position(Value In Array((Event Player).scrap_gun_pvar, 5), Add(Value In Array((Event Player).scrap_gun_pvar, 5), Multiply(8, Value In Array((Event Player).scrap_gun_pvar, 3))), All Players(Opposite Team Of(Team Of(Event Player))), Null, True));
        "exit if scrap hit enemy before explosion"
        Abort If(Compare(Distance Between(Value In Array((Event Player).scrap_gun_pvar, 5), First Of((Event Player).scrap_gun_pvar)), <, 8));
        Wait(0.1, Ignore Condition);
        Play Effect(All Players(All Teams), Explosion Sound, Color(Black), First Of((Event Player).scrap_gun_pvar), 100);
        Set Player Variable At Index(Event Player, scrap_gun_pvar, 2, Filtered Array(Players in View Angle(Event Player, Opposite Team Of(Team Of(Event Player)), 90), And(Or(Or(Is In Line of Sight(First Of((Event Player).scrap_gun_pvar), Eye Position(Current Array Element), Enemy Barriers Block LOS), Is In Line of Sight(First Of((Event Player).scrap_gun_pvar), Divide(Add(Position Of(Current Array Element), Eye Position(Current Array Element)), 2), Enemy Barriers Block LOS)), Is In Line of Sight(First Of((Event Player).scrap_gun_pvar), Position Of(Current Array Element), Enemy Barriers Block LOS)), Compare(Angle Between Vectors(Value In Array((Event Player).scrap_gun_pvar, 3), Direction Towards(First Of((Event Player).scrap_gun_pvar), Divide(Add(Position Of(Current Array Element), Eye Position(Current Array Element)), 2))), <, 15))));
        For Player Variable(Event Player, scrap_i, 0, Count Of(Value In Array((Event Player).scrap_gun_pvar, 2)), 1);
            "decrease damage quadratically with distance"
            Damage(Value In Array(Value In Array((Event Player).scrap_gun_pvar, 2), (Event Player).scrap_i), Event Player, Min(250, Divide(500, Distance Between(First Of((Event Player).scrap_gun_pvar), Divide(Add(Position Of(Value In Array(Value In Array((Event Player).scrap_gun_pvar, 2), (Event Player).scrap_i)), Eye Position(Value In Array(Value In Array((Event Player).scrap_gun_pvar, 2), (Event Player).scrap_i))), 2)))));
        End;
    }
}

rule ("[roadhog/scrap_gun.opy]: Record last time scrap gun fired") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Firing Primary(Event Player) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, scrap_gun_pvar, 4, Total Time Elapsed);
    }
}

rule ("[roadhog/init.opy]: Initialize Roadhog") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
        "guards against initialization when exiting wholehog"
        First Of((Event Player).wholehog_pvar) == False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 600);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2240);
        Set Ammo(Event Player, 0, 4);
        Set Max Ammo(Event Player, 0, 4);
        "Breather init"
        Disallow Button(Event Player, Button(Ability 2));
        Disallow Button(Event Player, Button(Secondary Fire));
        Set Secondary Fire Enabled(Event Player, False);
        Set Healing Dealt(Event Player, 75);
        Set Knockback Received(Event Player, 200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Preload Hero(Event Player, Hero(Zarya));
        Preload Hero(Event Player, Hero(Roadhog));
        Set Player Variable At Index(Event Player, wholehog_pvar, 0, False);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[sigma/accretion.opy]: set sigma stun") {
    event {
        Player Dealt Damage;
        All;
        Sigma;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        If(Has Status(Victim, Knocked Down));
            Set Status(Victim, Event Player, Knocked Down, Multiply(Absolute Value(Distance Between(Victim, Event Player)), 0.25));
    }
}

rule ("[sigma/accretion.opy]: Set sigma barrier cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Sigma;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Secondary Fire)) > 0;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 0.2);
    }
}

rule ("[sigma/init.opy]: Initialize Sigma") {
    event {
        Ongoing - Each Player;
        All;
        Sigma;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 250);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 200);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1600);
        Set Knockback Received(Event Player, 200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[sigma/init.opy]: Change accretion damage") {
    event {
        Player Dealt Damage;
        All;
        Sigma;
    }
    conditions {
        Event Ability == Button(Ability 2);
        "Checks for direct hit vs splash damage"
        Event Damage > 40;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.375), Event Damage));
    }
}

rule ("[sojourn/railgun.opy]: OW1 Railgun alt fire headshot damage") {
    event {
        Player Dealt Damage;
        All;
        Sojourn;
    }
    conditions {
        Array Contains(Array(Button(Secondary Fire), Button(Ultimate)), Event Ability) == True;
        Event Was Critical Hit == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), 1.466666666666666), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[sojourn/init.opy]: Initialize Sojourn") {
    event {
        Ongoing - Each Player;
        All;
        Sojourn;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2500);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[soldier/sprint.opy]: set cast time on sprint") {
    event {
        Ongoing - Each Player;
        All;
        Soldier: 76;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Primary Fire Enabled(Event Player, True);
        Set Secondary Fire Enabled(Event Player, True);
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Multiply, 0.97);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Set Primary Fire Enabled(Event Player, False);
        Set Secondary Fire Enabled(Event Player, False);
        Wait(0.5, Restart When True);
        Modify Player Variable At Index(Event Player, stat_helper_pvar, 2, Divide, 0.97);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).stat_helper_pvar, 2)));
        Set Primary Fire Enabled(Event Player, True);
        Set Secondary Fire Enabled(Event Player, True);
        Call Subroutine(startFiring);
    }
}

rule ("[soldier/pulse_rifle.opy]: Deal OW1 soldier primary fire damage") {
    event {
        Player Dealt Damage;
        All;
        Soldier: 76;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.052631578947368), Event Damage));
    }
}

rule ("[soldier/pulse_rifle.opy]: Set pulse rifle projectile") {
    event {
        Ongoing - Each Player;
        All;
        Soldier: 76;
    }
    conditions {
        Is Firing Primary(Event Player) == True;
    }
    actions {
        Wait(0.1, Ignore Condition);
        Abort If Condition Is False;
        Create Projectile(Orb Projectile, Event Player, Subtract(Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(Direction Towards(Eye Position(Event Player), Add(Add(Add(Eye Position(Event Player), Multiply(Facing Direction Of(Event Player), 5)), Multiply(Up, Random Real(-0.1, 0.1))), Multiply(Right, Random Real(-0.1, 0.1)))), 100)), All Players(Opposite Team Of(Team Of(Event Player))), Null, True), Facing Direction Of(Event Player)), Null, To World, Damage, Opposite Team Of(Team Of(Event Player)), 20, 2, 0, Bad Explosion, Explosion Sound, 0, 999999999999999, 5, 0, 0, 0);
        Wait(0.1, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[soldier/init.opy]: Initialize Soldier: 76") {
    event {
        Ongoing - Each Player;
        All;
        Soldier: 76;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1750);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[sombra/emp.opy]: Detect EMP casting") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Ultimate Charge Percent(Event Player) >= 100;
        Is Button Held(Event Player, Button(Ultimate)) == True;
    }
    actions {
        Wait Until(Compare(Ultimate Charge Percent(Event Player), ==, 0), 999999999999999);
        Set Player Variable At Index(Event Player, emp_pvar, 0, True);
        Wait(0.64, Ignore Condition);
        Set Player Variable At Index(Event Player, emp_pvar, 0, False);
    }
}

rule ("[sombra/emp.opy]: Break barrier with EMP") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        First Of((Event Player).emp_pvar) != False;
    }
    actions {
        "Deal 10000 damage to all barrier"
        Set Damage Dealt(Event Player, 100);
        Wait Until(Is Using Ultimate(Event Player), 999999999999999);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[sombra/emp.opy]: Remove OW2 EMP damage") {
    event {
        Player Dealt Damage;
        All;
        Sombra;
    }
    conditions {
        Event Ability == Button(Ultimate);
    }
    actions {
        Heal(Victim, Null, Event Damage);
        Damage(Victim, Attacker, Subtract(Health(Victim), Add(Health Of Type(Victim, Health), Health Of Type(Victim, Armor))));
    }
}

rule ("[sombra/stealth.opy]: Remove Stealth passive") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        First Of((Event Player).stealth_pvar) == False;
        Is Firing Primary(Event Player) == False;
        Is Firing Secondary(Event Player) == False;
        Is Meleeing(Event Player) == False;
    }
    actions {
        Damage(Event Player, Null, 0.000001);
        "some irrational value"
        Wait(0.999847695156391, Abort When False);
        Loop If Condition Is True;
    }
}

rule ("[sombra/stealth.opy]: Bind Ability 1 to stealth") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 1)) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
        First Of((Event Player).stealth_pvar) == False;
    }
    actions {
        Call Subroutine(enterStealth);
    }
}

rule ("[sombra/stealth.opy]: enterStealth()") {
    event {
        Subroutine;
        enterStealth;
    }
    actions {
        Set Ability 1 Enabled(Event Player, False);
        "Disable hacking during invis"
        Set Secondary Fire Enabled(Event Player, False);
        Wait(0.5, Ignore Condition);
        Call Subroutine(showStealthHud);
        Set Invisible(Event Player, Enemies);
        Set Move Speed(Event Player, 175);
        Set Player Variable At Index(Event Player, stealth_pvar, 0, True);
        Damage(Event Player, Null, 0.01);
        Heal(Event Player, Null, 0.01);
        Wait(3.5, Ignore Condition);
        Set Invisible(Event Player, None);
        Set Move Speed(Event Player, 120.6896551724138);
        Call Subroutine(exitStealth);
    }
}

rule ("[sombra/stealth.opy]: Exit Stealth when shooting") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        First Of((Event Player).stealth_pvar) != False;
        Or(Or(Or(Or(Is Button Held(Event Player, Button(Primary Fire)), Is Button Held(Event Player, Button(Secondary Fire))), Is Button Held(Event Player, Button(Melee))), Is Button Held(Event Player, Button(Ability 1))), Is Button Held(Event Player, Button(Ultimate))) == True;
    }
    actions {
        Call Subroutine(exitStealth);
        Set Ability Cooldown(Event Player, Button(Ability 1), 6);
    }
}

rule ("[sombra/stealth.opy]: Exit Stealth when taking damage") {
    event {
        Player Took Damage;
        All;
        Sombra;
    }
    conditions {
        First Of((Event Player).stealth_pvar) != False;
    }
    actions {
        Call Subroutine(exitStealth);
        Set Ability Cooldown(Event Player, Button(Ability 1), 6);
    }
}

rule ("[sombra/stealth.opy]: exitStealth()") {
    event {
        Subroutine;
        exitStealth;
    }
    actions {
        Destroy Effect(Value In Array((Event Player).stealth_pvar, 1));
        Set Player Variable At Index(Event Player, stealth_pvar, 1, Null);
        Damage(Event Player, Null, 0.01);
        Heal(Event Player, Null, 0.01);
        "Enable hacking after exiting invis"
        Set Secondary Fire Enabled(Event Player, True);
        Set Invisible(Event Player, None);
        Set Move Speed(Event Player, 100);
        Wait(0.60, Ignore Condition);
        Set Ability 1 Enabled(Event Player, True);
        Set Ability Cooldown(Event Player, Button(Ability 1), 6);
        Set Player Variable At Index(Event Player, stealth_pvar, 0, False);
    }
}

rule ("[sombra/stealth.opy]: showStealthHud()") {
    event {
        Subroutine;
        showStealthHud;
    }
    actions {
        If(Compare(Value In Array((Event Player).stealth_pvar, 1), ==, Null));
            Create Effect(Event Player, Sphere, Custom Color(100, 68, 179, 255), Event Player, 1, Visible To Position and Radius);
            Set Player Variable At Index(Event Player, stealth_pvar, 1, Last Created Entity);
        End;
    }
}

rule ("[sombra/translocator.opy]: Bind Ability 2 to translocator") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == False;
        Ability Cooldown(Event Player, Button(Ability 2)) <= 0;
        Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)) == False;
        First Of((Event Player).translocator_pvar) == False;
    }
    actions {
        Wait Until(Is Button Held(Event Player, Button(Ability 2)), 999999999999999);
        Set Ability Cooldown(Event Player, Button(Ability 2), 6);
        Call Subroutine(destroyTranslocator);
        Set Player Variable(Event Player, call_throwTranslocator, True);
        "calls throwTranslocator() and returns immediately instead of waiting"
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, call_throwTranslocator, False);
        Wait Until(Not(Is Button Held(Event Player, Button(Ability 2))), 999999999999999);
        "prevent tp when cc'd or when casting emp"
        Wait Until(And(And(Or(Or(Is Button Held(Event Player, Button(Ability 2)), Is Button Held(Event Player, Button(Interact))), Is Dead(Event Player)), Not(Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)))), Not(First Of((Event Player).emp_pvar))), 999999999999999);
        If(Is Button Held(Event Player, Button(Ability 2)));
            Play Effect(All Players(All Teams), Bad Pickup Effect, Color(Purple), Position Of(Event Player), 100);
            Play Effect(All Players(All Teams), Bad Pickup Effect, Color(Purple), Event Player, 100);
            Play Effect(All Players(All Teams), Buff Impact Sound, Color(Purple), (Event Player).transloc_position, 100);
            Teleport(Event Player, (Event Player).transloc_position);
        End;
        If(Is Button Held(Event Player, Button(Interact)));
            Play Effect(All Players(All Teams), Ring Explosion, Color(Purple), (Event Player).transloc_position, 3);
            Play Effect(All Players(All Teams), Explosion Sound, Color(Purple), (Event Player).transloc_position, 100);
        End;
        Call Subroutine(destroyTranslocator);
    }
}

rule ("[sombra/translocator.opy]: destroyTranslocator()") {
    event {
        Subroutine;
        destroyTranslocator;
    }
    actions {
        Stop Chasing Player Variable(Event Player, transloc_time);
        Stop Chasing Player Variable(Event Player, transloc_position);
        Stop Chasing Player Variable(Event Player, trasnloc_velocity);
        Set Player Variable(Event Player, transloc_time, Null);
        Set Player Variable(Event Player, transloc_position, Null);
        Set Player Variable(Event Player, trasnloc_velocity, Null);
        Call Subroutine(hideTranslocator);
        Set Player Variable At Index(Event Player, translocator_pvar, 0, False);
    }
}

rule ("[sombra/translocator.opy]: Call throwTranslocator()") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        (Event Player).call_throwTranslocator != False;
    }
    actions {
        Call Subroutine(throwTranslocator);
    }
}

rule ("[sombra/translocator.opy]: throwTranslocator()") {
    event {
        Subroutine;
        throwTranslocator;
    }
    actions {
        "Initialize translocator projectile"
        Set Player Variable(Event Player, transloc_v0, Multiply(25, Facing Direction Of(Event Player)));
        Set Player Variable(Event Player, transloc_p0, Eye Position(Event Player));
        Set Player Variable(Event Player, transloc_time, 0);
        Chase Player Variable At Rate(Event Player, transloc_time, 6, 1, Destination and Rate);
        Set Player Variable(Event Player, trasnloc_velocity, (Event Player).transloc_v0);
        Chase Player Variable At Rate(Event Player, trasnloc_velocity, Vector(X Component Of((Event Player).transloc_v0), Add(Multiply(-16, (Event Player).transloc_time), Y Component Of((Event Player).transloc_v0)), Z Component Of((Event Player).transloc_v0)), 9999, Destination and Rate);
        Set Player Variable(Event Player, transloc_position, (Event Player).transloc_p0);
        Chase Player Variable At Rate(Event Player, transloc_position, Vector(Add(Multiply(X Component Of((Event Player).transloc_v0), (Event Player).transloc_time), X Component Of((Event Player).transloc_p0)), Add(Add(Multiply(-8, Raise To Power((Event Player).transloc_time, 2)), Multiply(Y Component Of((Event Player).transloc_v0), (Event Player).transloc_time)), Y Component Of((Event Player).transloc_p0)), Add(Multiply(Z Component Of((Event Player).transloc_v0), (Event Player).transloc_time), Z Component Of((Event Player).transloc_p0))), 9999, Destination and Rate);
        Call Subroutine(showTranslocator);
        Set Player Variable At Index(Event Player, translocator_pvar, 0, True);
        Play Effect(All Players(All Teams), Buff Explosion Sound, Color(Purple), Event Player, 100);
        "Wait for translocator projectile to hit wall"
        Wait Until(Update Every Frame(Compare(Distance Between((Event Player).transloc_position, Ray Cast Hit Position((Event Player).transloc_position, Add((Event Player).transloc_position, (Event Player).trasnloc_velocity), Null, Null, False)), <, 0.5)), 6);
        "Freeze translocator projectile"
        Stop Chasing Player Variable(Event Player, transloc_time);
        Stop Chasing Player Variable(Event Player, trasnloc_velocity);
        Stop Chasing Player Variable(Event Player, transloc_position);
        "Play bouncing sound"
        Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Purple), (Event Player).transloc_position, 100);
        "Fall down to floor after bouncing off wall"
        Set Player Variable At Index(Event Player, barrier_pvar, 3, Ray Cast Hit Normal((Event Player).transloc_position, Add((Event Player).transloc_position, (Event Player).trasnloc_velocity), Null, Null, False));
        Set Player Variable(Event Player, transloc_v0, Multiply(0.03, Subtract((Event Player).trasnloc_velocity, Multiply(Multiply(2, Dot Product((Event Player).trasnloc_velocity, Value In Array((Event Player).barrier_pvar, 3))), Value In Array((Event Player).barrier_pvar, 3)))));
        Set Player Variable(Event Player, transloc_p0, (Event Player).transloc_position);
        Set Player Variable(Event Player, transloc_time, 0);
        Chase Player Variable At Rate(Event Player, transloc_time, 6, 1, Destination and Rate);
        Set Player Variable(Event Player, trasnloc_velocity, (Event Player).transloc_v0);
        Chase Player Variable At Rate(Event Player, trasnloc_velocity, Vector(X Component Of((Event Player).transloc_v0), Add(Multiply(-16, (Event Player).transloc_time), Y Component Of((Event Player).transloc_v0)), Z Component Of((Event Player).transloc_v0)), 9999, Destination and Rate);
        Set Player Variable(Event Player, transloc_position, (Event Player).transloc_p0);
        Chase Player Variable At Rate(Event Player, transloc_position, Vector(Add(Multiply(X Component Of((Event Player).transloc_v0), (Event Player).transloc_time), X Component Of((Event Player).transloc_p0)), Add(Add(Multiply(-8, Raise To Power((Event Player).transloc_time, 2)), Multiply(Y Component Of((Event Player).transloc_v0), (Event Player).transloc_time)), Y Component Of((Event Player).transloc_p0)), Add(Multiply(Z Component Of((Event Player).transloc_v0), (Event Player).transloc_time), Z Component Of((Event Player).transloc_p0))), 9999, Destination and Rate);
        "Wait for translocator projectile to hit ground"
        Wait Until(Update Every Frame(Compare(Distance Between((Event Player).transloc_position, Ray Cast Hit Position((Event Player).transloc_position, Add((Event Player).transloc_position, (Event Player).trasnloc_velocity), Null, Null, False)), <, 0.5)), 6);
        "Freeze translocator projectile"
        Stop Chasing Player Variable(Event Player, transloc_time);
        Stop Chasing Player Variable(Event Player, trasnloc_velocity);
        Stop Chasing Player Variable(Event Player, transloc_position);
        Call Subroutine(showTranslocatorIcon);
        "Play landing sound"
        Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Purple), (Event Player).transloc_position, 100);
    }
}

rule ("[sombra/translocator.opy]: showTranslocator()") {
    event {
        Subroutine;
        showTranslocator;
    }
    actions {
        "Draw translocator projectile object"
        If(Compare(Value In Array((Event Player).translocator_pvar, 1), ==, Null));
            Create Effect(All Players(All Teams), Orb, Color(Purple), (Event Player).transloc_position, 0.1, Position and Radius);
            Set Player Variable At Index(Event Player, translocator_pvar, 1, Last Created Entity);
        End;
    }
}

rule ("[sombra/translocator.opy]: showTranslocatorIcon()") {
    event {
        Subroutine;
        showTranslocatorIcon;
    }
    actions {
        "Draw translocator icons"
        If(Compare(Value In Array((Event Player).translocator_pvar, 2), ==, Null));
            Create Icon(Event Player, Add((Event Player).transloc_position, Multiply(0.5, Down)), Halo, Visible To Position and Color, Color(Sky Blue), False);
            Set Player Variable At Index(Event Player, translocator_pvar, 2, Last Created Entity);
        End;
        If(Compare(Value In Array((Event Player).translocator_pvar, 3), ==, Null));
            Create Icon(Event Player, (Event Player).transloc_position, Diamond, Visible To Position and Color, Color(Sky Blue), False);
            Set Player Variable At Index(Event Player, translocator_pvar, 3, Last Created Entity);
        End;
    }
}

rule ("[sombra/translocator.opy]: hideTranslocator()") {
    event {
        Subroutine;
        hideTranslocator;
    }
    actions {
        Destroy Effect(Value In Array((Event Player).translocator_pvar, 1));
        Set Player Variable At Index(Event Player, translocator_pvar, 1, Null);
        Destroy Icon(Value In Array((Event Player).translocator_pvar, 2));
        Set Player Variable At Index(Event Player, translocator_pvar, 2, Null);
        Destroy Icon(Value In Array((Event Player).translocator_pvar, 3));
        Set Player Variable At Index(Event Player, translocator_pvar, 3, Null);
    }
}

rule ("[sombra/translocator.opy]: Show using translocator GUI") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 2)) <= 0.2;
        First Of((Event Player).translocator_pvar) != False;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Ability 2), 0.5);
    }
}

rule ("[sombra/init.opy]: Initialize Sombra") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2000);
        Set Player Variable At Index(All Players(Team Of(Event Player)), reset_pvar, 3, Event Player);
        Set Player Variable At Index(All Players(Opposite Team Of(Team Of(Event Player))), reset_pvar, 6, Event Player);
        Disallow Button(Event Player, Button(Ability 1));
        Disallow Button(Event Player, Button(Ability 2));
        Set Player Variable At Index(Event Player, stealth_pvar, 0, False);
        "removeSelfHealing()"
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[sombra/init.opy]: Clean up Sombra") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Sombra);
    }
    actions {
        Wait Until(Compare(Hero Of(Event Player), !=, Hero(Sombra)), 999999999999999);
        Call Subroutine(exitStealth);
        Call Subroutine(destroyTranslocator);
    }
}

rule ("[symmetra/shield.opy]: set symmetras shield") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        Is True For Any(Remove From Array(All Living Players(Team Of(Event Player)), Event Player), Compare(First Of((Current Array Element).shield_pvar), !=, True)) == True;
        Is Button Held(Event Player, Button(Ability 2)) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) <= 0;
        Is True For Any(Filtered Array(Remove From Array(Filtered Array(All Living Players(Team Of(Event Player)), Compare(First Of((Current Array Element).shield_pvar), !=, True)), Event Player), Has Spawned(Current Array Element)), And(And(Is In View Angle(Event Player, Eye Position(Current Array Element), 45), Compare(Distance Between(Eye Position(Event Player), Eye Position(Current Array Element)), <, 20)), Is In Line of Sight(Eye Position(Event Player), Eye Position(Current Array Element), Barriers Do Not Block LOS))) == True;
        Count Of(Filtered Array(All Living Players(Team Of(Event Player)), Has Spawned(Current Array Element))) > 1;
        Is Alive(Event Player) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, shield_pvar, 1, First Of(Sorted Array(Filtered Array(Remove From Array(All Living Players(Team Of(Event Player)), Event Player), And(And(Has Spawned(Current Array Element), Compare(Distance Between(Eye Position(Event Player), Eye Position(Current Array Element)), <, 20)), Compare(First Of((Current Array Element).shield_pvar), !=, True))), Distance Between(Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(10, Facing Direction Of(Event Player))), All Players(Team Of(Event Player)), Event Player, True), Eye Position(Current Array Element)))));
        Play Effect(All Players(All Teams), Good Explosion, Team Of(Event Player), Eye Position(Value In Array((Event Player).shield_pvar, 1)), 1);
        Add Health Pool To Player(Value In Array((Event Player).shield_pvar, 1), Shields, 25, True, False);
        Set Player Variable(Value In Array((Event Player).shield_pvar, 1), hp, Last Created Health Pool);
        Small Message(Value In Array((Event Player).shield_pvar, 1), Custom String("+25 Shield From {0}", Event Player, Null, Null));
        Set Ability Cooldown(Event Player, Button(Ability 2), 1.5);
        If(Compare(Ammo(Event Player, 0), >=, 100));
            Set Ammo(Event Player, 0, 99);
        End;
        Disallow Button(Event Player, Button(Ability 1));
        Press Button(Event Player, Button(Reload));
        Wait(0.5, Ignore Condition);
        If(Is Reloading(Event Player));
            Cancel Primary Action(Event Player);
        End;
        If(Compare(Ammo(Event Player, 0), >=, 99));
            Set Ammo(Event Player, 0, 100);
        End;
        Allow Button(Event Player, Button(Ability 1));
    }
}

rule ("[symmetra/beam.opy]: set sym primary fire") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        Is Button Held(Event Player, Button(Primary Fire)) == True;
        Is Alive(Event Player) == True;
        Is Meleeing(Event Player) == False;
        Is Firing Secondary(Event Player) == False;
        Is Reloading(Event Player) == False;
        Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Hacked)), Has Status(Event Player, Asleep)), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)) == False;
    }
    actions {
        Set Ammo(Event Player, 0, Subtract(Ammo(Event Player, 0), 1));
        Damage(First Of(Sorted Array(Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))), And(And(And(Has Spawned(Event Player), Is In Line of Sight(Eye Position(Event Player), Eye Position(Current Array Element), Barriers Do Not Block LOS)), Is In View Angle(Event Player, Eye Position(Current Array Element), 60)), Compare(Distance Between(Eye Position(Event Player), Eye Position(Current Array Element)), <, 5))), Distance Between(Eye Position(Event Player), Eye Position(Current Array Element)))), Event Player, Multiply(Round To Integer((Event Player).beam_multiplier_dmg, Down), 11.52));
        Wait(0.13, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[symmetra/beam.opy]: make beam visible") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        Is Button Held(Event Player, Button(Primary Fire)) == True;
        Is Meleeing(Event Player) == False;
        Is Firing Secondary(Event Player) == False;
        Is Reloading(Event Player) == False;
    }
    actions {
        Set Player Variable(Event Player, beam_visibility, All Players(All Teams));
    }
}

rule ("[symmetra/beam.opy]: make beam not visible") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        Is Button Held(Event Player, Button(Primary Fire)) == False;
        Is Meleeing(Event Player) == False;
        Is Firing Secondary(Event Player) == False;
        Is Reloading(Event Player) == False;
    }
    actions {
        Set Player Variable(Event Player, beam_visibility, Null);
    }
}

rule ("[symmetra/beam.opy]: beam multiplier start") {
    event {
        Player Dealt Damage;
        All;
        Symmetra;
    }
    conditions {
        Event Ability != Button(Secondary Fire);
        Event Ability != Button(Ability 1);
        Event Ability != Button(Melee);
    }
    actions {
        Stop Chasing Player Variable(Event Player, beam_multiplier_dmg);
        Modify Player Variable(Event Player, beam_multiplier_dmg, Add, 0.15);
        Wait(0.13, Restart When True);
        Chase Player Variable At Rate(Event Player, beam_multiplier_dmg, 1, 0.5, Destination and Rate);
    }
}

rule ("[symmetra/beam.opy]: symmetra multipier correction") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        (Event Player).beam_multiplier_dmg >= 4;
    }
    actions {
        Set Player Variable(Event Player, beam_multiplier_dmg, 3.9);
    }
}

rule ("[symmetra/orb.opy]: set turret speed") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Projectile Speed(Event Player, 1000);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Set Projectile Speed(Event Player, 100);
    }
}

rule ("[symmetra/orb.opy]: symmetra allow turrets") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        Distance Between(Eye Position(Event Player), Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(6, Facing Direction Of(Event Player))), Null, Event Player, False)) < 5;
    }
    actions {
        Set Ability 1 Enabled(Event Player, True);
        Wait(0.016, Abort When False);
        Loop If Condition Is True;
    }
}

rule ("[symmetra/orb.opy]: symettra disallow turrets") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        Distance Between(Eye Position(Event Player), Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(6, Facing Direction Of(Event Player))), Null, Event Player, False)) > 5;
    }
    actions {
        Set Ability 1 Enabled(Event Player, False);
        If(Is Using Ability 1(Event Player));
            Cancel Primary Action(Event Player);
        End;
        Wait(0.016, Abort When False);
        Loop If Condition Is True;
    }
}

rule ("[symetra/teleporter.opy]: init teleporter") {
    event {
        Ongoing - Global;
    }
    actions {
        Chase Global Variable At Rate(teleporter1, Ray Cast Hit Position(First Of(Spawn Points(Team 1)), Add(First Of(Spawn Points(Team 1)), Multiply(Facing Direction Of(First Of(Spawn Points(Team 1))), 8)), Null, Null, False), 100, Destination and Rate);
        Chase Global Variable At Rate(teleporter2, Ray Cast Hit Position(First Of(Spawn Points(Team 2)), Add(First Of(Spawn Points(Team 2)), Multiply(Facing Direction Of(First Of(Spawn Points(Team 2))), 8)), Null, Null, False), 100, Destination and Rate);
        Create Effect(If-Then-Else(Is True For Any(All Players(Team 1), And(Compare(Hero Of(Current Array Element), ==, Hero(Symmetra)), (Current Array Element).teleporter_up)), All Players(All Teams), Null), Sphere, Team 1, Add(Global.teleporter1, Vector(0, 1, 0)), 0.75, Visible To Position and Radius);
        Create Effect(If-Then-Else(Is True For Any(All Players(Team 2), And(Compare(Hero Of(Current Array Element), ==, Hero(Symmetra)), (Current Array Element).teleporter_up)), All Players(All Teams), Null), Sphere, Team 2, Add(Global.teleporter2, Vector(0, 1, 0)), 0.75, Visible To Position and Radius);
        Create In-World Text(If-Then-Else(Is True For Any(All Players(Team 1), And(Compare(Hero Of(Current Array Element), ==, Hero(Symmetra)), (Current Array Element).teleporter_up)), All Players(All Teams), Null), Custom String("Teleporter by {0} (walk through to use)", First Of(Players On Hero(Hero(Symmetra), Team 1)), Null, Null), Add(Global.teleporter1, Vector(0, 1, 0)), 1, Clip Against Surfaces, Visible To Position and String, Team 1, Default Visibility);
        Create In-World Text(If-Then-Else(Is True For Any(All Players(Team 2), And(Compare(Hero Of(Current Array Element), ==, Hero(Symmetra)), (Current Array Element).teleporter_up)), All Players(All Teams), Null), Custom String("Teleporter by {0} (walk through to use)", First Of(Players On Hero(Hero(Symmetra), Team 2)), Null, Null), Add(Global.teleporter2, Vector(0, 1, 0)), 1, Clip Against Surfaces, Visible To Position and String, Team 2, Default Visibility);
    }
}

rule ("[symettra/teleporter.opy]: createTeleporter{}") {
    event {
        Subroutine;
        createTeleporter;
    }
    actions {
        Set Player Variable(Event Player, teleporter_up, False);
        Destroy Effect(Value In Array((Event Player).shield_gen_pvar, 1));
        Destroy In-World Text(Value In Array((Event Player).shield_gen_pvar, 2));
        Destroy Effect(Value In Array((Event Player).shield_gen_pvar, 3));
        Set Ultimate Charge(Event Player, 0);
        Set Player Variable(Event Player, teleporter_used, 6);
        Set Player Variable(Event Player, objective, Objective Index);
        Set Player Variable(Event Player, shield_gen, Empty Array);
        Set Player Variable At Index(Event Player, shield_gen_pvar, 5, Event Player);
        Set Player Variable At Index(Event Player, shield_gen_pvar, 4, Position Of(Event Player));
        Set Player Variable At Index(Event Player, shield_gen_pvar, 6, Multiply(Vector(X Component Of(Facing Direction Of(Event Player)), 0, Z Component Of(Facing Direction Of(Event Player))), -1));
        Create Effect(All Players(All Teams), Sphere, Color(Blue), Add((Event Player).cords, Vector(0, 0.75, 0)), 0.75, Visible To Position and Radius);
        Set Player Variable At Index(Event Player, shield_gen_pvar, 1, Last Created Entity);
        Create In-World Text(All Players(All Teams), Custom String("{0}'s Teleporter", Event Player, Null, Null), Add((Event Player).cords, Vector(0, 0.75, 0)), 1, Clip Against Surfaces, Visible To Position and String, Color(White), Default Visibility);
        Set Player Variable At Index(Event Player, shield_gen_pvar, 2, Last Text ID);
        Small Message(All Players(Team Of(Event Player)), Custom String("Teleporter created by {0}", Event Player, Null, Null));
        Set Player Variable(Event Player, teleporter_up, True);
    }
}

rule ("[symettra/teleporter.opy]: destroyTeleporter()") {
    event {
        Subroutine;
        destroyTeleporter;
    }
    actions {
        Set Ultimate Charge(Event Player, 0);
        Destroy Effect(Value In Array((Event Player).shield_gen_pvar, 1));
        Destroy In-World Text(Value In Array((Event Player).shield_gen_pvar, 2));
        Small Message(All Players(Team Of(Event Player)), Custom String(" {0}'s Teleporter has been destroyed", Event Player, Null, Null));
        Set Player Variable(Event Player, teleporter_up, False);
        If(And(Not(And(Compare(Count Of(Players Within Radius(Value In Array((Event Player).shield_gen_pvar, 4), 2, Opposite Team Of(Team Of(Event Player)), Off)), >, 0), Is Button Held(First Of(Players Within Radius(Value In Array((Event Player).shield_gen_pvar, 4), 2, Opposite Team Of(Team Of(Event Player)), Off)), Button(Primary Fire)))), Compare((Event Player).objective, !=, Objective Index)));
            Set Ultimate Charge(Event Player, Multiply(16.667, (Event Player).teleporter_used));
        End;
        Set Player Variable(Event Player, teleporter_used, 0);
    }
}

rule ("[symettra/teleporter.opy]: spawn teleporter") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        Is True For Any(Global.shield_gen, Compare(Event Player, ==, First Of(Current Array Element))) == False;
        Is Button Held(Event Player, Button(Ultimate)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Alive(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Primary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Set Player Variable(Event Player, cords, Position Of(Event Player));
        Chase Player Variable At Rate(Event Player, cords, Ray Cast Hit Position(Add(Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(Vector(X Component Of(Facing Direction Of(Event Player)), 0, Z Component Of(Facing Direction Of(Event Player))), 2.5)), Null, Event Player, True), Up), Add(Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(Vector(X Component Of(Facing Direction Of(Event Player)), 0, Z Component Of(Facing Direction Of(Event Player))), 10)), Null, Event Player, True), World Vector Of(Vector(False, -100, -20), Event Player, Rotation)), Null, Event Player, True), 1000, Destination and Rate);
        Create Effect(Event Player, Sphere, Color(Blue), (Event Player).cords, 0.75, Position and Radius);
        Set Player Variable At Index(Event Player, shield_gen_pvar, 1, Last Created Entity);
        Create In-World Text(Event Player, Custom String("DEPLOY {0} |                     | {1} CANCEL", Input Binding String(Button(Primary Fire)), Input Binding String(Button(Secondary Fire)), Null), Update Every Frame(Add(Add(Eye Position(Event Player), Multiply(Facing Direction Of(Event Player), 10)), Vector(0, -0.65, 0))), 1.3, Do Not Clip, Visible To Position and String, Color(White), Default Visibility);
        Set Player Variable At Index(Event Player, shield_gen_pvar, 2, Last Text ID);
        Create Beam Effect(Event Player, Good Beam, Add((Event Player).cords, Vector(0, 0.3, 0)), Add(Add((Event Player).cords, Vector(0, 0.3, 0)), Multiply(Vector(X Component Of(Facing Direction Of(Event Player)), 0, Z Component Of(Facing Direction Of(Event Player))), -1.25)), Color(Blue), Position and Radius);
        Set Player Variable At Index(Event Player, shield_gen_pvar, 3, Last Created Entity);
        Wait(0.016, Ignore Condition);
        Wait Until(Or(Is Button Held(Event Player, Button(Secondary Fire)), Is Button Held(Event Player, Button(Primary Fire))), 999999999999999);
        Stop Chasing Player Variable(Event Player, cords);
        Destroy Effect(Value In Array((Event Player).shield_gen_pvar, 1));
        Destroy In-World Text(Value In Array((Event Player).shield_gen_pvar, 2));
        Destroy Effect(Value In Array((Event Player).shield_gen_pvar, 3));
        Allow Button(Event Player, Button(Primary Fire));
        Allow Button(Event Player, Button(Secondary Fire));
        If(Is Button Held(Event Player, Button(Primary Fire)));
            Call Subroutine(createTeleporter);
            Press Button(Event Player, Button(Reload));
            Wait(2, Ignore Condition);
            Wait Until(Or(Or(Or(Is Button Held(Event Player, Button(Ultimate)), Compare((Event Player).teleporter_used, <=, 0)), And(Compare(Count Of(Players Within Radius((Event Player).shield_gen, 2, Opposite Team Of(Team Of(Event Player)), Off)), >, 0), Is Button Held(First Of(Players Within Radius((Event Player).shield_gen, 2, Opposite Team Of(Team Of(Event Player)), Off)), Button(Primary Fire)))), Compare((Event Player).objective, !=, Objective Index)), 999999999999999);
            Call Subroutine(destroyTeleporter);
    }
}

rule ("[symettra/teleporter.opy]: remove tp if player left") {
    event {
        Player Left Match;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Symmetra);
        Is True For Any(Global.shield_gen, Compare(Event Player, ==, First Of(Current Array Element))) == True;
    }
    actions {
        Call Subroutine(destroyTeleporter);
    }
}

rule ("[symettra/teleporter.opy]: tp player with tp 1") {
    event {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions {
        Distance Between(Position Of(Event Player), Global.teleporter1) < 1;
        Number Of Heroes(Hero(Symmetra), Team Of(Event Player)) > 0;
        (First Of(Players On Hero(Hero(Symmetra), Team Of(Event Player)))).teleporter_up != False;
        Has Spawned(Event Player) == True;
        Is Alive(Event Player) == True;
    }
    actions {
        Play Effect(All Players(All Teams), Good Explosion, Team Of(Event Player), Evaluate Once(Position Of(Event Player)), 1);
        Teleport(Event Player, (First Of(Players On Hero(Hero(Symmetra), Team Of(Event Player)))).cords);
        Set Facing(Event Player, Add(Value In Array((First Of(Players On Hero(Hero(Symmetra), Team Of(Event Player)))).shield_gen_pvar, 6), Vector(0, Y Component Of(Facing Direction Of(Event Player)), 0)), To World);
        Play Effect(All Players(All Teams), Good Explosion, Team Of(Event Player), Position Of(Event Player), 1);
        Modify Player Variable(First Of(Players On Hero(Hero(Symmetra), Team Of(Event Player))), teleporter_used, Subtract, 1);
    }
}

rule ("[symettra/teleporter.opy]: tp player with tp 2") {
    event {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions {
        Distance Between(Position Of(Event Player), Global.teleporter2) < 1;
        Number Of Heroes(Hero(Symmetra), Team Of(Event Player)) > 0;
        (First Of(Players On Hero(Hero(Symmetra), Team Of(Event Player)))).teleporter_up != False;
        Has Spawned(Event Player) == True;
        Is Alive(Event Player) == True;
    }
    actions {
        Play Effect(All Players(All Teams), Good Explosion, Team Of(Event Player), Evaluate Once(Position Of(Event Player)), 1);
        Teleport(Event Player, (First Of(Players On Hero(Hero(Symmetra), Team Of(Event Player)))).cords);
        Set Facing(Event Player, Add(Value In Array((First Of(Players On Hero(Hero(Symmetra), Team Of(Event Player)))).shield_gen_pvar, 6), Vector(0, Y Component Of(Facing Direction Of(Event Player)), 0)), To World);
        Play Effect(All Players(All Teams), Good Explosion, Team Of(Event Player), Position Of(Event Player), 1);
        Modify Player Variable(First Of(Players On Hero(Hero(Symmetra), Team Of(Event Player))), teleporter_used, Subtract, 1);
    }
}

rule ("[symmetra/init.opy]: Initialize Symmetra") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 100);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 125);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Global Variable(shield_gen, Empty Array);
        Set Global Variable(radius, True);
        Set Primary Fire Enabled(Event Player, False);
        Disallow Button(Event Player, Button(Ability 2));
        Disallow Button(Event Player, Button(Ultimate));
        Create Beam Effect((Event Player).beam_visibility, Good Beam, Update Every Frame(Add(Add(Add(Eye Position(Event Player), Facing Direction Of(Event Player)), Multiply(World Vector Of(Right, Event Player, Rotation), 0.28)), Multiply(Normalize(Cross Product(Facing Direction Of(Event Player), World Vector Of(Right, Event Player, Rotation))), 0.19))), If-Then-Else(Entity Exists(First Of(Sorted Array(Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))), And(And(And(Has Spawned(Event Player), Is In Line of Sight(Eye Position(Event Player), Eye Position(Current Array Element), Barriers Do Not Block LOS)), Is In View Angle(Event Player, Eye Position(Current Array Element), 60)), Compare(Distance Between(Eye Position(Event Player), Eye Position(Current Array Element)), <, 5))), Distance Between(Eye Position(Event Player), Eye Position(Current Array Element))))), Add(Eye Position(First Of(Sorted Array(Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))), And(Has Spawned(Current Array Element), Is In View Angle(Event Player, Eye Position(Current Array Element), 60))), Distance Between(Eye Position(Event Player), Eye Position(Current Array Element))))), Vector(0, -0.3, 0)), Update Every Frame(Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(3, Facing Direction Of(Event Player))), Null, Null, False))), Team Of(Event Player), Visible To Position and Radius);
        Set Player Variable At Index(Event Player, beam_effects, 0, Last Created Entity);
        Create Effect((Event Player).beam_visibility, Energy Sound, Team Of(Event Player), Update Every Frame(Eye Position(Event Player)), 100, Visible To Position and Radius);
        Set Player Variable At Index(Event Player, beam_effects, 1, Last Created Entity);
        Set Player Variable(Event Player, beam_multiplier_dmg, 1);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[symmetra/init.opy]: Clean up Symmetra") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Symmetra);
    }
    actions {
        Wait Until(Compare(Hero Of(Event Player), !=, Hero(Symmetra)), 999999999999999);
        Call Subroutine(destroyTeleporter);
        Set Global Variable(shield_gen, Empty Array);
        Set Global Variable(radius, False);
    }
}

rule ("[torbjorn/rivet.opy]: 3 rivet ammo consumption.") {
    event {
        Ongoing - Each Player;
        All;
        Torbjörn;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Firing Secondary(Event Player)), 999999999999999);
        Set Ammo(Event Player, 0, Max(0, Add(Ammo(Event Player, 0), 2)));
        Set Ammo(Event Player, 0, Max(0, Subtract(Ammo(Event Player, 0), 3)));
    }
}

rule ("[torbjorn/init.opy]: Initialize Torbjorn") {
    event {
        Ongoing - Each Player;
        All;
        Torbjörn;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 50);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[tracer/init.opy]: Initialize Tracer") {
    event {
        Ongoing - Each Player;
        All;
        Tracer;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 150);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1500);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[venture/init.opy]: Initialize Venture") {
    event {
        Ongoing - Each Player;
        All;
        Venture;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1925);
        Set Knockback Received(Event Player, 200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[widowmaker/init.opy]: Initialize Widowmaker") {
    event {
        Ongoing - Each Player;
        All;
        Widowmaker;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2000);
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, True);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[widowmaker.opy]: Revert sniper damage falloff") {
    event {
        Player Dealt Damage;
        All;
        Widowmaker;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Is Firing Primary(Event Player) == True;
        Event Ability == Button(Primary Fire);
    }
    actions {
        Set Player Variable At Index(Event Player, fall_off_pvar, 0, Distance Between(Eye Position(Attacker), Victim));
        Set Player Variable At Index(Event Player, fall_off_pvar, 2, Add(Multiply(Divide(Subtract(First Of((Event Player).fall_off_pvar), 50), 20), 0.5), Subtract(1, Divide(Subtract(First Of((Event Player).fall_off_pvar), 50), 20))));
        "Cap min/max scalar\nMax damage scalar"
        If(Compare(Value In Array((Event Player).fall_off_pvar, 2), >, 1));
            Set Player Variable At Index(Event Player, fall_off_pvar, 2, 1);
        "Min damage scalar"
        Else If(Compare(Value In Array((Event Player).fall_off_pvar, 2), <, 0.5));
            Set Player Variable At Index(Event Player, fall_off_pvar, 2, 0.5);
        End;
        Set Player Variable At Index(Event Player, fall_off_pvar, 1, Divide(Event Damage, Value In Array((Event Player).fall_off_pvar, 2)));
        Set Player Variable At Index(Event Player, fall_off_pvar, 3, Add(Multiply(Divide(Subtract(First Of((Event Player).fall_off_pvar), 70), 30), 0.3), Subtract(1, Divide(Subtract(First Of((Event Player).fall_off_pvar), 70), 30))));
        "Cap min/max scalar\nMax damage scalar"
        If(Compare(Value In Array((Event Player).fall_off_pvar, 3), >, 1));
            Set Player Variable At Index(Event Player, fall_off_pvar, 3, 1);
        "Min damage scalar"
        Else If(Compare(Value In Array((Event Player).fall_off_pvar, 3), <, 0.3));
            Set Player Variable At Index(Event Player, fall_off_pvar, 3, 0.3);
        End;
        Set Player Variable At Index(Event Player, fall_off_pvar, 4, Multiply(Value In Array((Event Player).fall_off_pvar, 1), Value In Array((Event Player).fall_off_pvar, 3)));
        Damage(Victim, Attacker, Subtract(Value In Array((Event Player).fall_off_pvar, 4), Event Damage));
    }
}

rule ("[winston/leap.opy]: Override leap cooldown during primal") {
    event {
        Ongoing - Each Player;
        All;
        Winston;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) > 0;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Ability 1), 2);
    }
}

rule ("[winston/primal.opy]: Fix primal rage hp") {
    event {
        Ongoing - Each Player;
        All;
        Winston;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 850);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 150);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        "Recreate primal exit hp logic"
        Set Player Variable At Index(Event Player, primal_pvar, 0, Health Of Type(Event Player, Health));
        Set Player Variable At Index(Event Player, primal_pvar, 1, Health Of Type(Event Player, Armor));
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 400);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 100);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Health(Event Player, Add(Min(400, First Of((Event Player).primal_pvar)), Value In Array((Event Player).primal_pvar, 1)));
    }
}

rule ("[winston/init.opy]: Initialize Winston") {
    event {
        Ongoing - Each Player;
        All;
        Winston;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 400);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 100);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2300);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 0.866666666666666);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Knockback Received(Event Player, 200);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        "disable sniper monkey"
        Set Secondary Fire Enabled(Event Player, False);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[winston/init.opy]: Compensate Winston global damage reduction") {
    event {
        Player Dealt Damage;
        All;
        Winston;
    }
    conditions {
        Array Contains(Array(Button(Ability 1)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[zarya/self_bubble.opy]: zarya self bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 1));
        Set Ability Charge(Event Player, Button(Ability 1), 2);
        "wait bubble duration"
        Wait Until(Not(Is Using Ability 1(Event Player)), 3);
        Set Ability 1 Enabled(Event Player, False);
        Set Player Variable(Event Player, self_bubble_cooldown, 10);
        Allow Button(Event Player, Button(Ability 1));
        Chase Player Variable At Rate(Event Player, self_bubble_cooldown, 0, 1, None);
    }
}

rule ("[zarya/self_bubble.opy]: Disable self bubble if on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).self_bubble_cooldown > 0;
    }
    actions {
        Set Ability 1 Enabled(Event Player, False);
        If(Compare((Event Player).self_bubble_cd_text, ==, Null));
            Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).self_bubble_cooldown, Up), Null, Null), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(1.99, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.65, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
            Set Player Variable(Event Player, self_bubble_cd_text, Last Text ID);
    }
}

rule ("[zarya/self_bubble.opy]: Enable self bubble if not on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).self_bubble_cooldown <= 0;
    }
    actions {
        Set Ability 1 Enabled(Event Player, True);
        Destroy In-World Text((Event Player).self_bubble_cd_text);
        Set Player Variable(Event Player, self_bubble_cd_text, Null);
    }
}

rule ("[zarya/ally_bubble.opy]: zarya ally bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 2));
        Set Ability Charge(Event Player, Button(Ability 2), 2);
        Set Ability 2 Enabled(Event Player, False);
        "wait bubble duration"
        Wait(3, Ignore Condition);
        Set Player Variable(Event Player, ally_bubble_cooldown, 10);
        Allow Button(Event Player, Button(Ability 2));
        Chase Player Variable At Rate(Event Player, ally_bubble_cooldown, 0, 1, None);
    }
}

rule ("[zarya/ally_bubble.opy]: Disable ally bubble if on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).ally_bubble_cooldown > 0;
    }
    actions {
        Set Ability 2 Enabled(Event Player, False);
        If(Compare((Event Player).ally_bubble_cd_text, ==, Null));
            Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).ally_bubble_cooldown, Up), Null, Null), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(2.3, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.65, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
            Set Player Variable(Event Player, ally_bubble_cd_text, Last Text ID);
    }
}

rule ("[zarya/ally_bubble.opy]: Enable ally bubble if not on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).ally_bubble_cooldown <= 0;
    }
    actions {
        Set Ability 2 Enabled(Event Player, True);
        Destroy In-World Text((Event Player).ally_bubble_cd_text);
        Set Player Variable(Event Player, ally_bubble_cd_text, Null);
    }
}

rule ("[zarya/init.opy]: Initialize Zarya") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
        "guards against initialization when exiting wholehog"
        First Of((Event Player).wholehog_pvar) == False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 200);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1700);
        Set Player Variable At Index(Event Player, stat_helper_pvar, 0, 1.052631578947368);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).stat_helper_pvar)));
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Knockback Received(Event Player, 200);
        Set Player Variable(Event Player, self_bubble_cooldown, 0);
        Set Player Variable(Event Player, ally_bubble_cooldown, 0);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[zarya/init.opy]: Clean up Zarya") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Zarya);
    }
    actions {
        Wait Until(Compare(Hero Of(Event Player), !=, Hero(Zarya)), 999999999999999);
        Destroy In-World Text((Event Player).self_bubble_cd_text);
        Set Player Variable(Event Player, self_bubble_cd_text, Null);
        Destroy In-World Text((Event Player).ally_bubble_cd_text);
        Set Player Variable(Event Player, ally_bubble_cd_text, Null);
    }
}

rule ("[zarya/init.opy]: Compensate zarya global damage reduction") {
    event {
        Player Dealt Damage;
        All;
        Zarya;
    }
    conditions {
        Array Contains(Array(Button(Secondary Fire), Button(Ultimate)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).stat_helper_pvar)), Event Damage), First Of((Event Player).stat_helper_pvar)));
    }
}

rule ("[zenyatta/transc.opy]: Allow self healing during Transcendence") {
    event {
        Ongoing - Each Player;
        All;
        Zenyatta;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        If(Not(Array Contains(First Of((Event Player).self_heal_pvar), Button(Ultimate))));
            Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Append To Array, Button(Ultimate));
        End;
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Modify Player Variable At Index(Event Player, self_heal_pvar, 0, Remove From Array By Value, Button(Ultimate));
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, If-Then-Else(Compare(Count Of(First Of((Event Player).self_heal_pvar)), >, 0), 100, 0));
        Set Player Variable At Index(Event Player, self_heal_pvar, 5, If-Then-Else(Compare(Value In Array((Event Player).self_heal_pvar, 1), >, 0), True, False));
    }
}

rule ("[zenyatta/discord.opy]: Set discord orb") {
    event {
        Ongoing - Each Player;
        All;
        Zenyatta;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        "just leave this so they dont accidentally got the wrong target"
        Set Status(Event Player, Null, Stunned, 0.016);
        Set Damage Received(Player Closest To Reticle(Event Player, Opposite Team Of(Team Of(Event Player))), 200);
        Set Player Variable(Player Closest To Reticle(Event Player, Opposite Team Of(Team Of(Event Player))), discord_orb_damage, True);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999999999999);
        If(Remove From Array(Not((Event Player).discord_orb_damage), True));
            Set Player Variable(Event Player, discord_orb_damage, False);
    }
}

rule ("[zenyatta/discord.opy]: stop discord orb if no longer using it.") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).discord_orb_damage == False;
    }
    actions {
        Set Damage Received(Event Player, 100);
    }
}

rule ("[zenyatta/init.opy]: Initialize Zenyatta") {
    event {
        Ongoing - Each Player;
        All;
        Zenyatta;
    }
    conditions {
        First Of((Event Player).reset_pvar) != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 50);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 100);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2500);
        Set Player Variable At Index(Event Player, self_heal_pvar, 0, Empty Array);
        Set Player Variable At Index(Event Player, self_heal_pvar, 1, 0);
        If(Compare(Value In Array((Event Player).self_heal_pvar, 2), ==, Null));
            Start Healing Modification(Event Player, Event Player, Value In Array((Event Player).self_heal_pvar, 1), Receivers Healers and Healing Percent);
            Set Player Variable At Index(Event Player, self_heal_pvar, 2, Last Healing Modification ID);
        End;
        Set Knockback Dealt(Event Player, 6.666666666666667);
        Set Ammo(Event Player, 0, 20);
        Set Max Ammo(Event Player, 0, 20);
        Set Player Variable At Index(Event Player, reset_pvar, 0, False);
    }
}

rule ("[zenyatta/init.opy]: OW1 Zenyatta melee damage") {
    event {
        Player Dealt Damage;
        All;
        Zenyatta;
    }
    conditions {
        "for some reason, zenyatta melee doesn't show up as melee"
        Event Ability == Null;
        Is Meleeing(Event Player) == True;
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Multiply(0.5, Divide(Event Damage, First Of((Event Player).stat_helper_pvar)))));
    }
}

rule ("[debug.opy] Disable Inspector for performance") {
    event {
        Ongoing - Global;
    }
    conditions {
        Global.DEBUG_MODE == False;
    }
    actions {
        Disable Inspector Recording;
    }
}

rule ("[utilities/debug.opy]: global debug (Top Left)") {
    event {
        Ongoing - Global;
    }
    conditions {
        Global.DEBUG_MODE == True;
    }
    actions {
        Create HUD Text(All Players(All Teams), Custom String("Global", Null, Null, Null), Null, Null, Left, 0, Color(White), Null, Null, Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Custom String("Server Load = {0}%", Server Load, Null, Null), Null, Left, 1, Null, Color(White), Null, Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Custom String("Server Load Average = {0}%", Server Load Average, Null, Null), Null, Left, 1, Null, Color(White), Null, Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Custom String("Server Load Peak = {0}%", Server Load Peak, Null, Null), Null, Left, 1, Null, Color(White), Null, Visible To and String, Default Visibility);
    }
}

rule ("[utilities/debug.opy]: player debug (Top Right)") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Global.DEBUG_MODE == True;
    }
    actions {
        Create HUD Text(Event Player, Custom String("Event Player", Null, Null, Null), Null, Null, Right, 0, Color(White), Null, Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getSpeed() = {0}", Speed Of(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
    }
}

rule ("[debug.opy] unlimated ult") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Global.DEBUG_MODE == True;
        Is Button Held(Event Player, Button(Ultimate)) == True;
    }
    actions {
        Set Ultimate Charge(Event Player, 100);
        Press Button(Event Player, Button(Ultimate));
    }
}

rule ("[debug.opy] Show Player Damage/Healing") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Global.DEBUG_MODE != False;
    }
    actions {
        "most recent damage"
        Create In-World Text(If-Then-Else(Compare(Value In Array((Event Player).debug_pvar, 1), >, 0), All Players(All Teams), Null), Value In Array((Event Player).debug_pvar, 1), Add(Eye Position(Event Player), Multiply(0.5, Up)), 1, Do Not Clip, Visible To Position and String, Color(Red), Default Visibility);
        "total healing"
        Create In-World Text(If-Then-Else(Compare(Value In Array((Event Player).debug_pvar, 2), >, 0), All Players(All Teams), Null), Value In Array((Event Player).debug_pvar, 2), Add(Eye Position(Event Player), Up), 2, Do Not Clip, Visible To Position and String, Color(Yellow), Default Visibility);
        "total damage"
        Create In-World Text(If-Then-Else(Compare(First Of((Event Player).debug_pvar), >, 0), All Players(All Teams), Null), First Of((Event Player).debug_pvar), Add(Eye Position(Event Player), Multiply(1.5, Up)), 2, Do Not Clip, Visible To Position and String, Color(Red), Default Visibility);
        "most recent healing"
        Create In-World Text(If-Then-Else(Compare(Value In Array((Event Player).debug_pvar, 3), >, 0), All Players(All Teams), Null), Value In Array((Event Player).debug_pvar, 3), Add(Eye Position(Event Player), Multiply(2, Up)), 1, Do Not Clip, Visible To Position and String, Color(Yellow), Default Visibility);
    }
}

rule ("[debug.opy] Debug damage instance") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        Global.DEBUG_MODE != False;
    }
    actions {
        Log To Inspector(Custom String("attacker={0}, victim={1}, ability={2}", Attacker, Victim, Custom String("{0}, amount={1}", Event Ability, Event Damage, Null)));
        Set Player Variable At Index(Victim, debug_pvar, 1, Event Damage);
        Modify Player Variable At Index(Victim, debug_pvar, 0, Add, Event Damage);
        Wait(2, Restart When True);
        Set Player Variable At Index(Victim, debug_pvar, 1, 0);
        Set Player Variable At Index(Victim, debug_pvar, 0, 0);
    }
}

rule ("[debug.opy] Debug healing instance") {
    event {
        Player Received Healing;
        All;
        All;
    }
    conditions {
        Global.DEBUG_MODE != False;
    }
    actions {
        Log To Inspector(Custom String("healer={0}, healee={1}, ability={2}", Healer, Healee, Custom String("{0}, amount={1}", Event Ability, Event Healing, Null)));
        Set Player Variable At Index(Healee, debug_pvar, 3, Event Healing);
        Modify Player Variable At Index(Healee, debug_pvar, 2, Add, Event Healing);
        Wait(2, Restart When True);
        Set Player Variable At Index(Healee, debug_pvar, 3, 0);
        Set Player Variable At Index(Healee, debug_pvar, 2, 0);
    }
}

rule ("[debug.opy] dummybot testing") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Global.DEBUG_MODE != False;
        Is Button Held(Event Player, Button(Interact)) == True;
        Is Button Held(Event Player, Button(Crouch)) == True;
    }
    actions {
        Destroy All Dummy Bots;
        Create Dummy Bot(Hero(Ana), Opposite Team Of(Team Of(Event Player)), -1, Event Player, Event Player);
    }
}

rule ("[debug.opy] damage player") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Global.DEBUG_MODE != False;
        Is Button Held(Event Player, Button(Interact)) == True;
        Is Button Held(Event Player, Button(Primary Fire)) == True;
    }
    actions {
        Set Status(Event Player, Null, Unkillable, 2);
        Damage(Event Player, Null, 999999999999999);
    }
}

rule ("[debug.opy] heal player") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Global.DEBUG_MODE != False;
        Is Button Held(Event Player, Button(Interact)) == True;
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
    }
    actions {
        Heal(Event Player, Null, 1);
        Wait(0.016, Ignore Condition);
        Loop If Condition Is True;
    }
}

